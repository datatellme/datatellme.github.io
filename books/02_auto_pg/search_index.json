[["index.html", "파이썬 자동화 프로그램 만들기 이 책에게 관하여", " 파이썬 자동화 프로그램 만들기 psnam 2025-05-29 이 책에게 관하여 이 책은 파이썬 자동화 프로그램을 제작하기 위해서 작성했습니다. "],["Sub00_2025-05-26-22-29.html", "Chapter 1 오디오 CD를 mp3 파일로 전환하여 하나의 mp3파일로 합치기 1.1 들어가며 1.2 업무자동화 설계하기 1.3 코딩하기 1.4 결어", " Chapter 1 오디오 CD를 mp3 파일로 전환하여 하나의 mp3파일로 합치기 1.1 들어가며 여러개의 mp3 파일을 하나의 Mp3 파일로 합치는 자동화 프로그램을 만듭니다. 오디오 CD에서 mp3 파일로 변환면 트랙별로 만들어집니다. 각 트랙의 mp3 파일을 하나의 mp3 파일로 합칩니다. 1.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 예전에 듣던 클래식 오디오 CD가 있는데 CD 플래이어가 없어서 mp3 파일로 변환해서 듣고자 합니다. CD 플에이어가 장착되어 있는 예전 노트북을 찾아 미디어 플래이어로 오디오를 mp3로 변환 합니다. 왜 만드는가? 핸드폰이나 아이패드에 mp3 파일을 복사하여 클래식 음악을 듣기 위해서 만들게 되었습니다. 작업 쪼개기 핵심 내용: 1단계: 오디오 CD를 mp3로 변환하여 A폴더에 준비합니다. 2단계: A폴더에 있는 mp3 파일들을 순서대로 합쳐서 B폴더에 A폴더 이름으로 mp3파일을 생성합니다. 3단계: 배치 파일을 만들어 실행합니다. 필요 라이브러리 설치 moviepy: mp3를 합치는 라이브러리 tqdm: 진행 상황을 나타내는 라이브러리 pip install moviepy tqdm pip install moviepy 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install moviepy 실행 %PYTHON_PATH% -m pip install moviepy pause 1.3 코딩하기 1 단계 작업 윈도우 10기본 프로그램인 윈도우 미디어 풀레이어를 실행합니다 구성 -&gt; 옵션 음악복사 형식 mp3, 자동으로 CD 복사, 복사가 끝나면 CD 꺼내기, 오디오 음질: 128-320kbps 셋팅 CD 복사 2 단계 작업 clips.append(audio): 리스트에 클립을 추가하는 부분입니다. write_audiofile(): 오디오 저장하기 입니다. 출력 MP3는 moviepy에서 내부적으로 ffmpeg를 사용하므로, 시스템에 ffmpeg가 설치되어 있어야 오류 없이 작동합니다. from moviepy.editor import concatenate_audioclips, AudioFileClip import os from tqdm import tqdm from datetime import datetime # 원본 Mp3 파일이 있는 폴더 path = r&quot;D:\\music\\WRC_003SB\\WRC_003SB_The Destiny&quot; # 합쳐진 Mp3 파일을 저장할 폴더 output_path = r&quot;D:\\music\\WRC_000SB_all_01&quot; # Mp3 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # Mp3 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mp3&#39;)]) # 모든 오디오 클립 읽기 clips = [] print(&quot; Mp3 파일 읽는 중...&quot;) for file_name in tqdm(file_list, desc=&quot;MP3 읽는 중&quot;): mp3_file = os.path.join(path, file_name) try: audio = AudioFileClip(mp3_file) clips.append(audio) except Exception as e: print(f&quot;❌ 오류 발생: {file_name} - {e}&quot;) # 오디오 클립 이어붙이기 if clips: print(&quot;️ 클립 합치는 중...&quot;) final_clip = concatenate_audioclips(clips) # 현재 시각 기반 동적 파일명 생성 folder_name = os.path.basename(path.rstrip(&quot;\\/&quot;)) timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H%M&quot;) output_filename = f&quot;{folder_name}_{timestamp}.mp3&quot; output_file = os.path.join(output_path, output_filename) # 최종 파일 저장 final_clip.write_audiofile(output_file) # 모든 클립 닫기 for clip in clips: clip.close() print(f&quot;✅ 모든 Mp3 파일이 저장되었습니다: {output_file}&quot;) else: print(&quot;❌ 합칠 mp3 파일이 없습니다.&quot;) 3 단계 작업 실행 배치파일을 아래와 같이 작성하면 따로 비주얼 스튜디오와 같은 것을 사용하지 않아도 됩니다 파일명은 같게 Mp3_convert_all_01.bat로 합니다. @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mp3_convert_all_01.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 1.4 결어 집에 있는 오디오 CD를 풀레이어가 없어서 못듣고 있으시면 이 방법을 사용하여 음악을 들으실 수 있습니다. mp3 파일들을 트랙단위로 전환되지만 노래 단위로 묶을 수 있습니다. 핸드폰이나 아패드에 mp3를 복사하셔서 음악을 항상 들이 실 수 있습니다 "],["Sub00_2025-05-28-10-58.html", "Chapter 2 jpg파일들을 전자책(epub)으로 만들기 2.1 들어가며 2.2 업무자동화 설계하기 2.3 코딩하기 2.4 결어", " Chapter 2 jpg파일들을 전자책(epub)으로 만들기 2.1 들어가며 여러개의 jpg 파일들을 하나의 epub 파일로 합치는 자동화 프로그램을 만든다. 손쉽게 전자책을 만들 수 있다. 2.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 여러 개의 .jpg 이미지를 하나의 EPUB 전자책으로 만들기 각 이미지는 한 페이지로 취급 표지, 목차, 타이틀 자동 생성 (기본 설정) 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 pip install ebooklib pillow tqdm pip install ebooklib 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install ebooklib 실행 %PYTHON_PATH% -m pip install ebooklib pause 2.3 코딩하기 1 단계 작업 2 단계 작업 .epub 확장자: 전자책 표준 형식 각 이미지 → HTML 페이지: 책의 각 페이지로 렌더링됨 태그 사용: 이미지가 직접 페이지로 표시됨 이미지 파일을 epub 내부에 추가 (book.add_item) HTML 페이지에서 img src=“images/파일명.jpg”로 참조 img src=“images/xxx.jpg”: base64 대신 외부 파일 참조 방식 book.add_item(image_item): 이미지 파일을 EPUB 패키지에 등록 HTML 페이지를 epub.EpubHtml로 각각 생성: ReadEra 호환 spine 구성 유지 from ebooklib import epub from PIL import Image import os from tqdm import tqdm from datetime import datetime # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\A&quot; ConvertedToEpubPath = r&quot;D:\\vFlat\\epub&quot; os.makedirs(ConvertedToEpubPath, exist_ok=True) file_list = sorted(f for f in os.listdir(path) if f.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;))) book = epub.EpubBook() folder_name = os.path.basename(path.rstrip(&quot;\\\\/&quot;)) timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H%M&quot;) title = f&quot;{folder_name}_{timestamp}&quot; book.set_title(title) book.set_language(&#39;ko&#39;) book.add_author(&#39;AutoEPUB Generator&#39;) epub_pages = [] for idx, filename in enumerate(tqdm(file_list, desc=&quot;EPUB 생성 중&quot;)): image_path = os.path.join(path, filename) # 이미지 파일을 책에 추가 image_item = epub.EpubItem( uid=f&quot;img{idx}&quot;, file_name=f&quot;images/{filename}&quot;, media_type=&quot;image/jpeg&quot;, content=open(image_path, &#39;rb&#39;).read() ) book.add_item(image_item) # 각 페이지 HTML 작성 (외부 참조 방식) html = f&#39;&#39;&#39; &lt;html&gt; &lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt; &lt;body style=&quot;text-align:center; margin:0; padding:0; background-color:black;&quot;&gt; &lt;img src=&quot;images/{filename}&quot; style=&quot;width:100%; max-width:100%;&quot;/&gt; &lt;/body&gt; &lt;/html&gt; &#39;&#39;&#39; page = epub.EpubHtml(title=f&#39;Page {idx+1}&#39;, file_name=f&#39;page_{idx+1}.xhtml&#39;, content=html) book.add_item(page) epub_pages.append(page) # Spine 및 TOC book.toc = tuple(epub_pages) book.spine = [&#39;nav&#39;] + epub_pages book.add_item(epub.EpubNcx()) book.add_item(epub.EpubNav()) # 저장 output_filename = f&quot;{title}.epub&quot; output_path = os.path.join(ConvertedToEpubPath, output_filename) epub.write_epub(output_path, book, {}) print(f&quot;✅ ReadEra 호환 EPUB 저장 완료: {output_path}&quot;) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\jpg_convert_epub.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 2.4 결어 "],["Sub00_2025-05-28-12-24.html", "Chapter 3 jpg파일들을 pdf로 만들기 3.1 들어가며 3.2 업무자동화 설계하기 3.3 코딩하기 3.4 결어", " Chapter 3 jpg파일들을 pdf로 만들기 3.1 들어가며 여러개의 jpg 파일들을 하나의 pdf 파일로 합치는 자동화 프로그램을 만든다. 3.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 pip install pillow tqdm pip install tqdm 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install tqdm 실행 %PYTHON_PATH% -m pip install tqdm pause 3.3 코딩하기 1 단계 작업 2 단계 작업 이미지가 들어 있는 폴더 경로: D: PDF가 저장될 폴더: D:_pdf: 폴더가 없다면 자동 생성 PDF 파일 이름: 현재 날짜+시간 기반으로 동적으로 생성: 예: Converted_2025-04-25_1423.pdf from PIL import Image import os from datetime import datetime from tqdm import tqdm # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\A&quot; # PDF 저장 폴더 ConvertedToPdfPath = r&quot;D:\\vFlat\\Apdf&quot; # PDF 저장 폴더가 없다면 생성 os.makedirs(ConvertedToPdfPath, exist_ok=True) # 파일 목록 불러오기 및 정렬 file_list = sorted(os.listdir(path)) # 이미지 리스트 생성 img_list = [] k = 0 for i in tqdm(file_list): if i.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;)): k += 1 if k % 100 == 0: print(f&quot;Progress : {k}/{len(file_list)}&quot;) img = Image.open(os.path.join(path, i)) img_rgb = img.convert(&#39;RGB&#39;) img_list.append(img_rgb) # PDF 저장 if img_list: # 현재 시각 기반 동적 파일명 folder_name = os.path.basename(path.rstrip(&quot;\\\\/&quot;)) timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H%M&quot;) output_filename = f&quot;{folder_name}_{timestamp}.pdf&quot; output_path = os.path.join(ConvertedToPdfPath, output_filename) first_img = img_list[0] rest_imgs = img_list[1:] first_img.save(output_path, save_all=True, append_images=rest_imgs) print(f&quot;PDF Saved: {output_path}&quot;) else: print(&quot;No Image File&quot;) 3 단계 작업 run_convert.bat 파일을 더블 클릭하면 Python 가상환경의 convert_to_pdf.py가 실행되어 자동으로 PDF 변환을 수행합니다. 완료 후 콘솔창이 멈춰 있어 결과 메시지를 확인할 수 있습니다. D:\\ ├─vFlat\\ │ ├─A\\ &lt;- 이미지 폴더 │ ├─A_pdf\\ &lt;- PDF 저장 폴더 │ ├─convert_to_pdf.py │ └─run_convert.bat &lt;- 더블 클릭해서 실행 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\jpg_convert_pdf.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 3.4 결어 "],["Sub00_2025-05-28-15-56.html", "Chapter 4 JPG 이미지를 각각 하나의 TXT 파일로 저장하기 4.1 들어가며 4.2 업무자동화 설계하기 4.3 코딩하기 4.4 결어", " Chapter 4 JPG 이미지를 각각 하나의 TXT 파일로 저장하기 4.1 들어가며 4.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 pip install pillow pytesseract tqdm pip install pillow 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install pillow 실행 %PYTHON_PATH% -m pip install pillow pause 4.3 코딩하기 1 단계 작업 2 단계 작업 lang=’eng+kor’은 영어 + 한글 인식을 위해 설정한 것입니다. → tesseract에 kor 언어 데이터가 설치되어 있어야 작동합니다. 이미지 이름이 test001.jpg면 → test001.txt로 저장됩니다. 100개마다 진행 상황을 출력합니다. 폴더 안의 모든 JPG 이미지를 각각 하나의 TXT 파일로 저장하는 파이썬 코드의 완성본입니다. from PIL import Image import pytesseract import os from tqdm import tqdm # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\man_A02&quot; # TXT 저장 폴더 ConvertedToTxtPath01 = r&quot;D:\\vFlat\\Atxt02&quot; # TXT 저장 폴더가 없다면 생성 os.makedirs(ConvertedToTxtPath01, exist_ok=True) # 파일 목록 불러오기 및 정렬 file_list = sorted(os.listdir(path)) # 처리 시작 for idx, filename in tqdm(enumerate(file_list, start=1)): if filename.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;)): if idx % 100 == 0: print(f&quot;Progress: {idx}/{len(file_list)}&quot;) img_path = os.path.join(path, filename) img = Image.open(img_path) img_rgb = img.convert(&#39;RGB&#39;) # OCR 수행 pytesseract.pytesseract.tesseract_cmd = r&quot;C:\\Program Files\\Tesseract-OCR\\tesseract.exe&quot; text = pytesseract.image_to_string(img_rgb, lang=&#39;eng+kor&#39;) # 결과 저장할 TXT 파일 경로 설정 txt_filename = os.path.splitext(filename)[0] + &quot;.txt&quot; txt_path = os.path.join(ConvertedToTxtPath01, txt_filename) # 텍스트 파일로 저장 with open(txt_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f: f.write(text) print(&quot;모든 이미지가 텍스트 파일로 저장되었습니다.&quot;) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\jpg_convert_txt.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 4 단계 작업 D:_Atxt02 폴더 안의 모든 *.txt 파일을 하나로 합치는 batch 스크립트 파일명 순서대로 (오름차순) 정확하게 합치고 싶다면, copy *.txt는 안 되고, for문을 써야 해요. (echo?) off : 명령어 실행 내용을 화면에 표시하지 않음 (깔끔하게) cd /d D:_Atxt02 : 해당 폴더로 이동 (/d는 드라이브까지 이동할 때 필요) copy /b *.txt All.txt : 모든 .txt 파일을 이진 모드(binary mode)로 All.txt 파일로 합칩니다. (/b 옵션을 넣으면 깨짐을 방지할 수 있어요.) dir /b /on *.txt : 파일 이름 기준 오름차순 정렬 목록을 가져옴 for /f : 정렬된 파일 목록을 하나씩 순서대로 처리 type “파일명” &gt;&gt; “All.txt” : 하나씩 내용을 이어붙임 (append) pause : 명령어 실행 후 결과를 볼 수 있도록 멈춤 @echo off cd /d D:\\vFlat\\Atxt02 :: 폴더가 없다면 먼저 생성 if not exist &quot;D:\\vFlat\\Atxt03&quot; ( mkdir &quot;D:\\vFlat\\Atxt03&quot; ) :: All.txt 초기화 (기존 파일 있으면 삭제) if exist &quot;D:\\vFlat\\Atxt03\\All.txt&quot; del &quot;D:\\vFlat\\Atxt03\\All.txt&quot; :: 파일명을 오름차순으로 하나씩 읽어서 All.txt에 추가 for /f &quot;delims=&quot; %%i in (&#39;dir /b /on *.txt&#39;) do ( type &quot;%%i&quot; &gt;&gt; &quot;D:\\vFlat\\Atxt03\\All.txt&quot; ) pause 4.4 결어 "],["Sub00_2025-05-28-16-22.html", "Chapter 5 여러 개의 mp4 파일을 읽어서 mp3로 변환하기 5.1 들어가며 5.2 업무자동화 설계하기 5.3 코딩하기 5.4 결어", " Chapter 5 여러 개의 mp4 파일을 읽어서 mp3로 변환하기 5.1 들어가며 5.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 5.3 코딩하기 1 단계 작업 2 단계 작업 여러 개의 mp4 파일을 읽어서 mp3로 변환하고 D:저장하는 파이썬 코드 tqdm 으로 변환 진행 상황을 진행바로 볼 수 있어요. 오디오가 없는 mp4는 건너뛰고 경고를 출력합니다. 저장할 mp3 이름은 원본 mp4 파일 이름을 따릅니다. from moviepy.editor import VideoFileClip import os from tqdm import tqdm # 원본 mp4 파일이 있는 폴더 path = r&quot;C:\\gppj\\data\\worship&quot; # 변환된 mp3 파일을 저장할 폴더 output_path = r&quot;D:\\music&quot; # Mp3 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # mp4 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mp4&#39;)]) # 변환 시작 for file_name in tqdm(file_list, desc=&quot;MP4 to MP3 변환 중&quot;): mp4_file = os.path.join(path, file_name) mp3_file = os.path.join(output_path, os.path.splitext(file_name)[0] + &quot;.mp3&quot;) try: clip = VideoFileClip(mp4_file) if clip.audio is not None: clip.audio.write_audiofile(mp3_file) clip.close() else: print(f&quot;오디오가 없는 파일입니다: {file_name}&quot;) except Exception as e: print(f&quot;오류 발생: {file_name} - {e}&quot;) print(&quot;✅ 모든 MP4 파일이 MP3로 변환되었습니다.&quot;) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mp4_convert_Mp3.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 5.4 결어 "],["Sub00_2025-05-28-22-07.html", "Chapter 6 모든 MOV 파일이 MP4로 변환하기 6.1 들어가며 6.2 업무자동화 설계하기 6.3 코딩하기 6.4 결어", " Chapter 6 모든 MOV 파일이 MP4로 변환하기 6.1 들어가며 6.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 6.3 코딩하기 1 단계 작업 2 단계 작업 from moviepy.editor import VideoFileClip import os from tqdm import tqdm # 원본 MOV 파일이 있는 폴더 path = r&quot;D:\\data\\stock video\\20230501&quot; # 변환된 Mp4 파일을 저장할 폴더 output_path = r&quot;D:\\data\\moviepy\\20230501&quot; # Mp4 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # MOV 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mov&#39;)]) # 변환 시작 for file_name in tqdm(file_list, desc=&quot;MOV to MP4 변환 중&quot;): mov_file = os.path.join(path, file_name) mp4_file = os.path.join(output_path, os.path.splitext(file_name)[0] + &quot;.mp4&quot;) try: clip = VideoFileClip(mov_file) clip.write_videofile(mp4_file, codec=&quot;libx264&quot;, audio_codec=&quot;aac&quot;, preset=&quot;ultrafast&quot;) except Exception as e: print(f&quot;오류 발생: {file_name} - {e}&quot;) finally: if &#39;clip&#39; in locals(): clip.close() print(&quot;✅ 모든 MOV 파일이 MP4로 변환되었습니다.&quot;) 병렬 변환 버전 코드 Python concurrent.futures 의 ProcessPoolExecutor를 써서 MOV 파일 여러 개를 동시에 변환합니다. CPU 코어를 활용해서 2배~5배 빠르게 변환할 수 있어요. 각 MOV 파일 하나씩 별도의 프로세스에서 변환하니까 안전합니다. from moviepy.editor import VideoFileClip import os from tqdm import tqdm from concurrent.futures import ProcessPoolExecutor, as_completed # 원본 MOV 파일이 있는 폴더 path = r&quot;D:\\data\\stock video\\20230501&quot; # 변환된 Mp4 파일을 저장할 폴더 output_path = r&quot;D:\\data\\moviepy\\20230501&quot; # Mp4 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # MOV 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mov&#39;)]) # 변환 함수 정의 def convert_mov_to_mp4(file_name): mov_file = os.path.join(path, file_name) mp4_file = os.path.join(output_path, os.path.splitext(file_name)[0] + &quot;.mp4&quot;) try: clip = VideoFileClip(mov_file) clip.write_videofile(mp4_file, codec=&quot;libx264&quot;, audio_codec=&quot;aac&quot;, preset=&quot;ultrafast&quot;, threads=4) return f&quot;완료: {file_name}&quot; except Exception as e: return f&quot;오류 발생: {file_name} - {e}&quot; finally: if &#39;clip&#39; in locals(): clip.close() # 병렬 변환 실행 if __name__ == &quot;__main__&quot;: max_workers = os.cpu_count() - 1 or 1 # CPU 개수 - 1 만큼 사용 with ProcessPoolExecutor(max_workers=max_workers) as executor: futures = {executor.submit(convert_mov_to_mp4, file_name): file_name for file_name in file_list} for future in tqdm(as_completed(futures), total=len(futures), desc=&quot;MOV to MP4 변환 중 (병렬)&quot;): result = future.result() print(result) print(&quot;✅ 모든 MOV 파일이 MP4로 병렬 변환 완료되었습니다.&quot;)  핵심 변경사항 ProcessPoolExecutor: CPU 병렬 처리 executor.submit(): 파일별로 변환 작업 배정 as_completed(): 완료된 작업부터 하나씩 tqdm 진행 threads=4 옵션 추가: write_videofile 안에서도 내부적으로 병렬 처리  병렬 버전 사용 시 주의 1개 MOV 파일당 메모리를 꽤 먹기 때문에 메모리(램) 여유가 있어야 합니다. (파일당 300~800MB 정도) 너무 많은 프로세스를 동시에 돌리면 PC가 버벅일 수 있어요. (그래서 cpu_count()-1로 제한) 디스크 I/O 속도(SSD vs HDD)에 따라서도 속도가 다를 수 있습니다. 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mov_convert_Mp4_01.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 6.4 결어 "],["Sub00_2025-05-28-16-33.html", "Chapter 7 폴더 안에 있는 모든 .mp4 파일을 순서대로 하나의 파일로 합치는 것 7.1 들어가며 7.2 업무자동화 설계하기 7.3 코딩하기 7.4 결어", " Chapter 7 폴더 안에 있는 모든 .mp4 파일을 순서대로 하나의 파일로 합치는 것 7.1 들어가며 7.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 7.3 코딩하기 1 단계 작업 2 단계 작업 VideoFileClip으로 mp4들을 모두 읽어온 뒤 concatenate_videoclips로 한 번에 이어붙여서 하나의 최종 .mp4 파일로 저장해야 합니다. concatenate_videoclips 사용 여러 개 mp4 파일을 하나로 이어붙임 for 반복하면서 파일마다 저장 ❌ 전부 메모리에 읽은 다음 한번에 합쳐서 저장 method=“compose” 사용 해상도/코덱이 서로 달라도 합칠 수 있게 함 모든 파일 clip.close() 메모리 릴리즈 (안 하면 누수 위험 있음) from moviepy.editor import VideoFileClip, concatenate_videoclips import os from tqdm import tqdm # 원본 Mp4 파일이 있는 폴더 path = r&quot;D:\\data\\moviepy\\20230501&quot; # 합쳐진 Mp4 파일을 저장할 폴더 output_path = r&quot;D:\\data\\moviepy\\20230501_all&quot; # Mp4 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # Mp4 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mp4&#39;)]) # 모든 클립 읽기 clips = [] print(&quot; Mp4 파일 읽는 중...&quot;) for file_name in tqdm(file_list, desc=&quot;MP4 읽는 중&quot;): mp4_file = os.path.join(path, file_name) try: clip = VideoFileClip(mp4_file) clips.append(clip) except Exception as e: print(f&quot;오류 발생: {file_name} - {e}&quot;) # 클립 이어붙이기 if clips: print(&quot;️ 클립 합치는 중...&quot;) final_clip = concatenate_videoclips(clips, method=&quot;compose&quot;) # method=&quot;compose&quot;로 서로 다른 해상도도 가능 # 최종 파일 저장 output_file = os.path.join(output_path, &quot;all.mp4&quot;) final_clip.write_videofile(output_file, codec=&quot;libx264&quot;, audio_codec=&quot;aac&quot;, preset=&quot;ultrafast&quot;) # 모든 클립 닫기 for clip in clips: clip.close() print(&quot;✅ 모든 Mp4 파일이 all.mp4로 합쳐졌습니다.&quot;) else: print(&quot;❌ 합칠 mp4 파일이 없습니다.&quot;) 파일 크기가 커질 수 있어요. (compose 쓸 때) 만약 모든 소스 mp4가 해상도, 코덱이 같으면 method=“chain”으로 더 빠르게 합칠 수 있습니다: final_clip = concatenate_videoclips(clips, method=&quot;chain&quot;) preset=“ultrafast”를 주면 저장 속도가 빨라지지만, 파일 용량은 살짝 늘어납니다. 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mp4_convert_all.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 7.4 결어 "],["Sub00_2025-05-28-21-13.html", "Chapter 8 자막 파일(subtitles.txt)을 읽고, 각 MP4 클립에 대응되는 자막을 삽입한 뒤, 모든 클립을 하나로 합치 8.1 들어가며 8.2 업무자동화 설계하기 8.3 코딩하기 8.4 결어", " Chapter 8 자막 파일(subtitles.txt)을 읽고, 각 MP4 클립에 대응되는 자막을 삽입한 뒤, 모든 클립을 하나로 합치 8.1 들어가며 8.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 8.3 코딩하기 1 단계 작업 2 단계 작업 각 VideoFileClip 위에 TextClip을 만들어 CompositeVideoClip으로 합칩니다. 자막은 클립 시작 0~2초 사이에 나타나도록 설정합니다. 그 후 concatenate_videoclips()로 모두 이어붙입니다. subtitles.txt 파일은 mp4 개수와 줄 수가 동일해야 가장 정확합니다. 부족한 줄은 자동으로 Clip N: 파일명으로 대체됩니다. sutf-8 인코딩을 사용하면 한글 자막도 문제 없이 적용됩니다. from moviepy.editor import VideoFileClip, TextClip, CompositeVideoClip, concatenate_videoclips import os from tqdm import tqdm # 원본 Mp4 파일이 있는 폴더 path = r&quot;D:\\data\\moviepy\\20230501&quot; # 합쳐진 Mp4 파일을 저장할 폴더 output_path = r&quot;D:\\data\\moviepy\\20230501_all&quot; os.makedirs(output_path, exist_ok=True) # 자막 텍스트 파일 경로 subtitle_file = os.path.join(path, &quot;subtitles.txt&quot;) # Mp4 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mp4&#39;)]) # 자막 텍스트 파일 읽기 if os.path.exists(subtitle_file): with open(subtitle_file, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f: subtitles = [line.strip() for line in f.readlines()] else: subtitles = [] # 자막 파일 없으면 빈 리스트 clips = [] print(&quot; Mp4 파일 읽는 중 및 자막 적용 중...&quot;) for idx, file_name in enumerate(tqdm(file_list, desc=&quot;MP4 처리 중&quot;)): mp4_file = os.path.join(path, file_name) try: base_clip = VideoFileClip(mp4_file) # 자막 텍스트 선택 if idx &lt; len(subtitles): subtitle_text = subtitles[idx] else: subtitle_text = f&quot;Clip {idx+1}: {file_name}&quot; # 자막 클립 생성 txt_clip = TextClip(subtitle_text, fontsize=40, color=&#39;white&#39;, font=&quot;C:/Windows/Fonts/NanumGothicBold.ttf&quot;, # ← 한글 폰트 method=&#39;caption&#39;, # ← 줄바꿈 가능 size=(clip.w - 100, None) # ← 텍스트 최대 너비 지정 (영상 너비보다 작게) ) txt_clip = txt_clip.set_duration(2).set_position((&#39;center&#39;, &#39;bottom&#39;)) # 자막과 비디오 클립 합성 composite = CompositeVideoClip([base_clip, txt_clip.set_start(0)]) clips.append(composite) except Exception as e: print(f&quot;❌ 오류 발생: {file_name} - {e}&quot;) # 모든 클립 이어붙이기 if clips: print(&quot;️ 클립 이어붙이는 중...&quot;) final_clip = concatenate_videoclips(clips, method=&quot;compose&quot;) output_file = os.path.join(output_path, &quot;all_with_subtitles.mp4&quot;) final_clip.write_videofile(output_file, codec=&quot;libx264&quot;, audio_codec=&quot;aac&quot;, preset=&quot;ultrafast&quot;) # 리소스 해제 for clip in clips: clip.close() print(&quot;✅ 완료! 자막 포함 mp4가 저장되었습니다.&quot;) else: print(&quot;⚠️ 클립이 존재하지 않거나 처리 중 오류가 발생했습니다.&quot;) 필요 구성 예시 D:\\data\\moviepy\\20230501\\ ├── clip01.mp4 ├── clip02.mp4 ├── clip03.mp4 ├── subtitles.txt ← 자막 한 줄씩 작성 ✅ subtitles.txt 예시 인트로 영상입니다. 서울의 거리 풍경 마무리 영상입니다.  자막 위치/스타일 변경 팁 설정 항목 위치 예시 글자 크기 fontsize=40 fontsize=60 으로 키우기 글자 색 color=‘white’ ‘yellow’, ‘red’ 등 배경 제거 bg_color=‘black’ 삭제 투명 배경 자막 위치 .set_position((‘center’, ‘bottom’)) ‘top’, ‘left’, ‘right’ 등 폰트 경로 직접 지정 (폰트 이름 충돌 피하기) txt_clip = TextClip(subtitle_text, fontsize=40, color=&#39;white&#39;, bg_color=&#39;black&#39;, font=&quot;C:/Windows/Fonts/malgun.ttf&quot;) 자막이 길 때 자동으로 두 줄, 세 줄로 줄바꿈 처리되게 하려면, TextClip에서 method=’caption’과 size=(너비, 높이) 옵션을 설정해줌l. ✅ 한글 + 자동 줄바꿈 자막 예제 txt_clip = TextClip( subtitle_text, fontsize=40, color=&#39;white&#39;, bg_color=&#39;black&#39;, font=&#39;Malgun Gothic&#39;, # ← 한글 폰트 method=&#39;caption&#39;, # ← 줄바꿈 가능 size=(clip.w - 100, None) # ← 텍스트 최대 너비 지정 (영상 너비보다 작게) ) txt_clip = txt_clip.set_duration(3).set_position((&#39;center&#39;, &#39;bottom&#39;))  설명 옵션 역할 method=‘caption’ 문장을 박스 안에서 자동 줄바꿈 해줌 size=(clip.w - 100, None) 텍스트 최대 너비 지정. 높이는 자동 font=‘Malgun Gothic’ 한글 폰트 명시  전체 사용 예시 (안에 넣는 부분만 발췌) clip = VideoFileClip(mp4_file) txt_clip = TextClip( subtitle_text, fontsize=40, color=&#39;white&#39;, bg_color=&#39;black&#39;, font=&#39;Malgun Gothic&#39;, method=&#39;caption&#39;, size=(clip.w - 100, None) ).set_duration(3).set_position((&#39;center&#39;, &#39;bottom&#39;)) composite = CompositeVideoClip([clip, txt_clip.set_start(0)]) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mp4_convert_all_txt.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 8.4 결어 "],["Sub00_2025-05-28-21-42.html", "Chapter 9 각 MP4 파일에 자막을 입히고, 각각 따로 자막 포함 개별 영상 저장하기 9.1 들어가며 9.2 업무자동화 설계하기 9.3 코딩하기 9.4 결어", " Chapter 9 각 MP4 파일에 자막을 입히고, 각각 따로 자막 포함 개별 영상 저장하기 9.1 들어가며 9.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 9.3 코딩하기 1 단계 작업 2 단계 작업 from moviepy.editor import VideoFileClip, TextClip, CompositeVideoClip import os from tqdm import tqdm # 원본 Mp4 파일이 있는 폴더 path = r&quot;D:\\data\\moviepy\\20230501_choice&quot; # 자막 포함 Mp4 파일 저장할 폴더 output_path = r&quot;D:\\data\\moviepy\\20230501_subtitled&quot; os.makedirs(output_path, exist_ok=True) # 자막 텍스트 파일 경로 subtitle_file = os.path.join(path, &quot;subtitles.txt&quot;) # Mp4 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mp4&#39;)]) # 자막 텍스트 읽기 if os.path.exists(subtitle_file): with open(subtitle_file, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f: subtitles = [line.strip() for line in f.readlines()] else: subtitles = [] print(&quot; 각 클립에 자막 추가 및 개별 저장 중...&quot;) for idx, file_name in enumerate(tqdm(file_list, desc=&quot;자막 처리 중&quot;)): mp4_file = os.path.join(path, file_name) try: clip = VideoFileClip(mp4_file) # 자막 텍스트 if idx &lt; len(subtitles): subtitle_text = subtitles[idx] else: subtitle_text = f&quot;Clip {idx+1}: {file_name}&quot; # 기본 자막 클립 (흰색) main_txt = TextClip(subtitle_text, fontsize=150, color=&#39;white&#39;, font=&quot;C:/Windows/Fonts/NanumGothicBold.ttf&quot;, # ← 한글 폰트 method=&#39;caption&#39;, # ← 줄바꿈 가능 size=(clip.w - 100, None) # ← 텍스트 최대 너비 지정 (영상 너비보다 작게) ).set_duration(clip.duration).set_position((&#39;left&#39;, &#39;bottom&#39;)) # 그림자 자막 클립 (검정, 약간 아래/오른쪽) # shadow_txt = TextClip(subtitle_text, fontsize=150, color=&#39;black&#39;, # font=&quot;C:/Windows/Fonts/NanumGothicBold.ttf&quot;, # ← 한글 폰트 # method=&#39;caption&#39;, # ← 줄바꿈 가능 # size=(clip.w - 100, None) # ← 텍스트 최대 너비 지정 (영상 너비보다 작게) # ).set_duration(clip.duration).set_position((&#39;left&#39;, clip.h - 100.05)) # 약간 아래 위치 # 페이드 인/아웃 효과 main_txt = main_txt.fadein(1).fadeout(1) # shadow_txt = shadow_txt.fadein(0.5).fadeout(0.5) # 자막 합성 (#그림자 → 텍스트 → 영상) composite = CompositeVideoClip([clip, main_txt]) # 약간 아래 위치: shadow_txt, # 저장 파일명 output_filename = os.path.splitext(file_name)[0] + &quot;_subtitled.mp4&quot; output_file = os.path.join(output_path, output_filename) # 저장 composite.write_videofile(output_file, codec=&quot;libx264&quot;, audio_codec=&quot;aac&quot;, preset=&quot;ultrafast&quot;) composite.close() clip.close() except Exception as e: print(f&quot;❌ 오류 발생: {file_name} - {e}&quot;) print(&quot;✅ 모든 파일이 자막 포함 개별 영상으로 저장되었습니다.&quot;) 저장 결과 예시 D:\\data\\moviepy\\20230501_subtitled\\ ├── clip01_subtitled.mp4 ├── clip02_subtitled.mp4 ├── clip03_subtitled.mp4 ✏️ 자막이 보이지 않을 경우 확인할 것 subtitles.txt의 줄 수와 mp4 개수가 일치하는지 자막 문장이 빈 줄이 아닌지 폰트가 시스템에 설치되어 있는지 (예: Arial) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mp4_convert_sub.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 9.4 결어 "],["Sub00_2025-05-28-21-48.html", "Chapter 10 유튜브 다운로더 만들기 10.1 들어가며 10.2 업무자동화 설계하기 10.3 코딩하기 10.4 결어", " Chapter 10 유튜브 다운로더 만들기 10.1 들어가며 10.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 pip install pytubefix 10.3 코딩하기 1 단계 작업 2 단계 작업 YouTube 객체 생성 시 URL을 넣음. 가장 높은 화질(get_highest_resolution()) 스트림을 선택. 파일 크기를 가져와서 tqdm에 총량으로 설정. on_progress_callback에 직접 등록해서 chunk 단위로 pbar.update() 호출. 다운로드 완료 후 파일 경로 출력. 예외 발생 시 에러 메시지 출력. 사용자가 모드 선택 (1: 영상, 2: mp3 음원). 오디오 스트림만 다운로드. moviepy 라이브러리로 mp3로 변환. 변환 후 원본 audio 파일 삭제. from pytubefix import YouTube import os from tqdm import tqdm from moviepy.editor import AudioFileClip # 다운로드 된 파일을 저장할 폴더 output_path = r&quot;D:\\movie&quot; # 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) def download_youtube(): url = input(&quot;다운로드할 유튜브 영상 URL을 입력하세요: &quot;) mode = input(&quot;다운로드 모드 선택 (1: 동영상, 2: MP3 음원): &quot;).strip() try: yt = YouTube(url) file_size = None pbar = None def on_progress(stream, chunk, bytes_remaining): nonlocal file_size, pbar if file_size and pbar: current = file_size - bytes_remaining pbar.n = current pbar.refresh() yt.register_on_progress_callback(on_progress) if mode == &quot;1&quot;: stream = yt.streams.get_highest_resolution() elif mode == &quot;2&quot;: stream = yt.streams.filter(only_audio=True).order_by(&#39;abr&#39;).desc().first() else: print(&quot;잘못된 모드 선택입니다.&quot;) return file_size = stream.filesize print(f&quot;&#39;{yt.title}&#39; 다운로드 시작... (파일 크기: {round(file_size / (1024 * 1024), 2)} MB)&quot;) with tqdm(total=file_size, unit=&#39;B&#39;, unit_scale=True, desc=yt.title) as pbar_instance: pbar = pbar_instance downloaded_path = stream.download(output_path=output_path) if mode == &quot;2&quot;: mp3_path = os.path.splitext(downloaded_path)[0] + &quot;.mp3&quot; print(f&quot;MP3 변환 중: {mp3_path}&quot;) audio_clip = AudioFileClip(downloaded_path) audio_clip.write_audiofile(mp3_path) audio_clip.close() os.remove(downloaded_path) print(f&quot;완료된 MP3 파일: {mp3_path}&quot;) else: print(f&quot;다운로드 완료: {downloaded_path}&quot;) except Exception as e: print(f&quot;다운로드 중 오류가 발생했습니다: {e}&quot;) if __name__ == &quot;__main__&quot;: download_youtube() 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Youtube Download01.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 10.4 결어 "],["Sub00_2025-05-28-21-59.html", "Chapter 11 전체 재생목록(Playlist)에 있는 동영상들을 자동으로 순서대로 다운로드 11.1 들어가며 11.2 업무자동화 설계하기 11.3 코딩하기 11.4 결어", " Chapter 11 전체 재생목록(Playlist)에 있는 동영상들을 자동으로 순서대로 다운로드 11.1 들어가며 11.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 11.3 코딩하기 1 단계 작업 2 단계 작업  브라우저에서 URL 복사하는 법 원하는 웹페이지 열기 (유튜브 링크가 있는 페이지) 주소창 클릭 → 전체 선택 → Ctrl+C 또는 마우스 오른쪽 → 복사 코드의 page_url = “…” 부분에 붙여넣기  주요 포인트 Playlist: 재생목록의 모든 영상 URL을 자동으로 가져옴 progressive=True : 영상+오디오가 함께 있는 스트림 선택 order_by(‘resolution’).desc(): 가장 고해상도 영상 우선 다운로드 tqdm: 진행률 표시줄로 다운로드 상황 시각화 from pytubefix import Playlist, YouTube import os from tqdm import tqdm # 유튜브 재생목록 URL playlist_url = input(&quot;다운로드할 유튜브 재생목록 URL을 입력하세요: &quot;) # 다운로드 경로 output_path = r&quot;D:\\movie\\Miarti_Sewing Tips\\Tricks And Tips Jeans&quot; os.makedirs(output_path, exist_ok=True) # 재생목록 불러오기 playlist = Playlist(playlist_url) print(f&quot; 재생목록 제목: {playlist.title}&quot;) print(f&quot; 총 {len(playlist.video_urls)}개의 영상이 감지되었습니다.\\n&quot;) # 동영상 하나씩 다운로드 for url in tqdm(playlist.video_urls, desc=&quot;다운로드 중&quot;): try: yt = YouTube(url) stream = yt.streams.filter(progressive=True, file_extension=&#39;mp4&#39;)\\ .order_by(&#39;resolution&#39;).desc().first() if stream: print(f&quot; {yt.title} 다운로드 중...&quot;) stream.download(output_path) else: print(f&quot;❌ 스트림 없음: {url}&quot;) except Exception as e: print(f&quot;⚠️ 오류 발생: {url} - {e}&quot;) print(&quot;✅ 재생목록 전체 다운로드 완료!&quot;) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Youtube Download_all.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 11.4 결어 "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
