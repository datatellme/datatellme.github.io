[["index.html", "파이썬 자동화 프로그램 만들기 이 책에게 관하여", " 파이썬 자동화 프로그램 만들기 psnam 2025-08-07 이 책에게 관하여 이 책은 파이썬 자동화 프로그램을 제작하기 위해서 작성했습니다. "],["Sub00_2025-05-28-10-58.html", "Chapter 1 jpg파일들을 전자책(epub)으로 만들기 1.1 들어가며 1.2 필요 라이브러리 설치 1.3 python 코딩 설명 1.4 Batch Script 코드 설명 1.5 결어", " Chapter 1 jpg파일들을 전자책(epub)으로 만들기 1.1 들어가며 이 코드는 여러 개의 JPG 파일들을 하나의 전자책(ePub) 파일로 자동 변환하는 파이썬 프로그램을 제공합니다. 이미지 파일들을 전자책 형식으로 변환하여 다양한 플랫폼에서 편리하게 읽을 수 있도록 해줍니다. 특히, 이미지 중심의 자료(예: 그림책, 보고서 등)를 쉽게 전자책으로 만들 수 있습니다. 이 프로그램은 이미지를 ePub 파일 내에 삽입하고, 각 이미지를 페이지로 구성하기 위해 설계되었습니다. HTML을 사용하여 이미지를 참조하는 방식이 활용됩니다. 1.2 필요 라이브러리 설치 1. ebooklib: 역할: 전자책(ebook) 파일 처리 및 관리 기능을 제공합니다. 특징: ebook 파일 다운로드, 변환, 복원 등을 위한 핵심 라이브러리입니다. 다양한 ebook 형식 (EPUB, MOBI 등)을 지원하며, 파일을 효율적으로 관리하고 읽기/쓰기 작업을 수행할 수 있습니다. eBook의 구조를 분석하여 텍스트 내용, 이미지, 서명 등을 추출하고 조작하는 데 사용됩니다. 2. Pillow: 역할: 이미지 처리 및 편집 기능을 제공합니다. (특히 간단한 이미지 수정에 유용합니다.) 특징: 이미지 크기 조정, 회전, 변환, 필터링 등 다양한 이미지 편집 작업을 수행할 수 있습니다. 이미지를 읽고 쓰는 데 사용됩니다. 다양한 이미지 포맷 (JPEG, PNG, GIF 등)을 지원합니다. 3. tqdm (Tortoise Plot): 역할: 데이터 시각화 (특히 반복적인 작업을 보여주는 그래프)를 위한 도구입니다. 특징: 데이터의 크기가 커질수록 자동으로 그래프가 그려지도록 도와줍니다. 주석을 통해 각 단계별로 데이터를 보여주고, 진행 상황을 쉽게 파악할 수 있습니다. 다양한 종류의 그래프 (선, 막대, 원 등)를 지원합니다. pip install ebooklib pillow tqdm pip install ebooklib 실행 batch script 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install ebooklib 실행 %PYTHON_PATH% -m pip install ebooklib pause 1.3 python 코딩 설명 .epub 확장자: 전자책 표준 형식 각 이미지 → HTML 페이지: 책의 각 페이지로 렌더링됨 태그 사용: 이미지가 직접 페이지로 표시됨 이미지 파일을 epub 내부에 추가 (book.add_item) HTML 페이지에서 img src=“images/파일명.jpg”로 참조 img src=“images/xxx.jpg”: base64 대신 외부 파일 참조 방식 book.add_item(image_item): 이미지 파일을 EPUB 패키지에 등록 HTML 페이지를 epub.EpubHtml로 각각 생성: ReadEra 호환 spine 구성 유지 from ebooklib import epub from PIL import Image import os from tqdm import tqdm from datetime import datetime # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\A&quot; ConvertedToEpubPath = r&quot;D:\\vFlat\\epub&quot; os.makedirs(ConvertedToEpubPath, exist_ok=True) file_list = sorted(f for f in os.listdir(path) if f.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;))) book = epub.EpubBook() folder_name = os.path.basename(path.rstrip(&quot;\\\\/&quot;)) timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H%M&quot;) title = f&quot;{folder_name}_{timestamp}&quot; book.set_title(title) book.set_language(&#39;ko&#39;) book.add_author(&#39;AutoEPUB Generator&#39;) epub_pages = [] for idx, filename in enumerate(tqdm(file_list, desc=&quot;EPUB 생성 중&quot;)): image_path = os.path.join(path, filename) # 이미지 파일을 책에 추가 image_item = epub.EpubItem( uid=f&quot;img{idx}&quot;, file_name=f&quot;images/{filename}&quot;, media_type=&quot;image/jpeg&quot;, content=open(image_path, &#39;rb&#39;).read() ) book.add_item(image_item) # 각 페이지 HTML 작성 (외부 참조 방식) html = f&#39;&#39;&#39; &lt;html&gt; &lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt; &lt;body style=&quot;text-align:center; margin:0; padding:0; background-color:black;&quot;&gt; &lt;img src=&quot;images/{filename}&quot; style=&quot;width:100%; max-width:100%;&quot;/&gt; &lt;/body&gt; &lt;/html&gt; &#39;&#39;&#39; page = epub.EpubHtml(title=f&#39;Page {idx+1}&#39;, file_name=f&#39;page_{idx+1}.xhtml&#39;, content=html) book.add_item(page) epub_pages.append(page) # Spine 및 TOC book.toc = tuple(epub_pages) book.spine = [&#39;nav&#39;] + epub_pages book.add_item(epub.EpubNcx()) book.add_item(epub.EpubNav()) # 저장 output_filename = f&quot;{title}.epub&quot; output_path = os.path.join(ConvertedToEpubPath, output_filename) epub.write_epub(output_path, book, {}) print(f&quot;✅ ReadEra 호환 EPUB 저장 완료: {output_path}&quot;) 1.3.1 이미지 추가 방식 (Image Inclusion Method) 이 코드는 이미지를 ePub 파일 내에 추가하는 두 가지 주요 방식을 사용합니다. 태그 사용: 이미지를 직접 페이지로 표시합니다. img src=\"images/파일명.jpg\" 형태로 HTML 코드에서 참조됩니다. 외부 파일 참조 (External File Reference): 이미지 파일을 ePub 파일 내에 포함시키지 않고 외부 파일 경로를 참조하는 방식입니다. img src=\"images/xxx.jpg\" 형태로 HTML 코드에서 참조되며, book.add_item() 함수를 사용하여 이미지를 추가할 때 사용됩니다. 이 방식은 ePub 파일의 크기를 줄이는 데 도움이 될 수 있습니다. 1.3.2 이미지 추가 과정 (Image Addition Process) file_name=f&quot;images/{filename}&quot;, media_type=&quot;image/jpeg&quot;, content=open(image_path, &#39;rb&#39;).read() ) book.add_item(image_item) file_name: 이미지 파일의 전체 경로를 생성합니다 (images/파일명.jpg). media_type: 이미지 파일의 MIME 타입을 지정합니다 (예: “image/jpeg”). 이는 ePub 리더가 이미지를 올바르게 표시하는 데 중요합니다. content: 이미지 파일을 바이너리 데이터(binary data)로 읽어옵니다 (open(image_path, 'rb').read()). 'rb' 모드는 파일을 바이너리 읽기 모드로 엽니다. book.add_item(image_item): ebooklib의 book 객체에 이미지를 추가합니다. 이 작업은 ePub 파일에 이미지가 포함되도록 합니다. 1.3.3 각 페이지 HTML 작성 (HTML Page Creation) 이미지 파일을 ePub 내에 추가하기 위해, 각 이미지는 별도의 HTML 페이지로 구성됩니다. img src=\"images/xxx.jpg\"와 같이 &lt;img&gt; 태그를 사용하여 이미지 파일을 참조합니다. 이 방식은 외부 파일 참조 방식으로, ePub 파일의 크기를 줄이는 데 도움이 됩니다. 1.3.4 전체 과정 요약 (Overall Process Summary) 이미지 파일 목록 확인: 프로그램은 지정된 디렉토리에서 JPG 이미지 파일들을 찾습니다. 각 이미지 처리: 각 이미지를 읽어와서 ePub 파일에 추가할 준비를 합니다. 이 과정에서 이미지 파일의 경로, MIME 타입 및 바이너리 데이터가 결정됩니다. HTML 페이지 생성: 각 이미지를 위한 HTML 페이지를 생성합니다. 이 페이지는 &lt;img&gt; 태그를 사용하여 이미지를 표시하고, 적절한 스타일을 적용합니다. ePub 파일 생성: ebooklib 라이브러리를 사용하여 ePub 파일을 생성하고, HTML 페이지들을 결합합니다. 1.4 Batch Script 코드 설명 이 부분은 파이썬 실행 경로와 스크립트 파일 위치를 지정하는 데 사용됩니다. set PYTHON_PATH: 파이썬 인터프리터의 정확한 위치를 명시합니다. 이는 멀티 환경을 사용하는 경우 필수적입니다. set SCRIPT_PATH: 실행할 스크립트 파일(jpg_convert_epub.py)의 경로를 지정합니다. 스크립트가 현재 디렉토리가 아닌 다른 곳에 있는 경우 필요합니다. echo Start.: 스크립트 시작을 알리는 메시지를 출력합니다. @echo off: 명령을 출력하지 않음(이전 명령을 숨기기 위한 것) set PYTHON_PATH=\"C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe\"와 set SCRIPT_PATH=\"C:\\gppj\\auto_ver06\\jpg_convert_epub.py\": 이 두 줄은 파이썬 실행 경로 및 텍스트 파일의 경로를 설정 oem이라는 사용자 이름에서 myfirstenv라는 환경 변수를 사용하는 것으로 보아, Python을 설치된 환경에서 실행될 수 있도록 함 myfirstenv는 특정 Python 버전의 환경입니다. 이 환경 변수를 사용하여 명령어가 실행될 때 파이썬의 Python 인터프리터가 사용되도록 설정 echo Start. and echo Done.: 명령어를 출력 pause: 스크립트를 종료하지 않고 사용자에게 결과를 확인하도록 함 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\jpg_convert_epub.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 1.5 결어 이 Python 코드는 여러 개의 JPG 파일을 쉽고 효율적으로 전자책(ePub)으로 변환하는 강력한 도구입니다. ebooklib 라이브러리를 사용하여 ePub 파일 생성 및 관리를 자동화하고, 이미지 삽입 방식을 통해 사용자 정의가 가능합니다. 이 코드를 활용하면 이미지가 많은 자료를 편리하게 전자책 형태로 만들 수 있으며, 다양한 플랫폼에서 접근이 용이합니다. "],["Sub00_2025-05-28-12-24.html", "Chapter 2 jpg파일들을 pdf로 만들기 2.1 들어가며 2.2 2. 필요한 라이브러리 설치 2.3 python 코딩 설명 2.4 Batch Script 코드 설명 2.5 결어", " Chapter 2 jpg파일들을 pdf로 만들기 2.1 들어가며 여러개의 jpg 파일들을 하나의 pdf 파일로 합치는 자동화 프로그램을 만드는 파이썬 코드입니다. 이 Python 코드는 JPG 이미지 파일들을 개별적인 TXT 파일로 변환하는 스크립트입니다. 주어진 폴더 내의 모든 JPG 이미지를 읽어와 각 이미지 파일명과 동일한 이름의 TXT 파일을 생성하고, 그 안에 이미지 파일명을 저장합니다. 이 스크립트는 주로 이미지 처리 과정에서 이미지 파일 이름을 명확하게 기록하거나, 특정 작업을 위해 이미지 파일 정보를 TXT 형식으로 저장하는 데 사용될 수 있습니다. 코드 실행 전에는 PYTHON_PATH와 SCRIPT_PATH 환경 변수를 설정해야 합니다. 2.2 2. 필요한 라이브러리 설치 이 코드를 실행하기 위해서는 다음 라이브러리가 필요합니다. pip을 사용하여 설치할 수 있습니다. PIL (Pillow): 이미지 파일을 읽고 처리하는 데 사용되는 라이브러리입니다. pip install Pillow 명령어를 통해 설치할 수 있습니다. os: 운영체제와 상호작용하기 위한 라이브러리입니다. 파일 시스템 작업을 수행하는 데 필요합니다. (별도로 설치할 필요가 없습니다.) datetime: 날짜 및 시간 관련 작업을 위한 라이브러리입니다. 파일명에 타임스탬프를 추가하는 등 시간 정보를 다룰 때 사용될 수 있습니다. (별도로 설치할 필요가 없습니다.) tqdm: 프로세스의 진행 상황을 시각적으로 표시하는 데 사용되는 라이브러리입니다. 많은 수의 파일을 처리할 때 유용합니다. pip install tqdm 명령어를 통해 설치할 수 있습니다. pip install pillow tqdm pip install tqdm 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install tqdm 실행 %PYTHON_PATH% -m pip install tqdm pause 2.3 python 코딩 설명 이미지가 들어 있는 폴더 경로: D: PDF가 저장될 폴더: D:_pdf: 폴더가 없다면 자동 생성 PDF 파일 이름: 현재 날짜+시간 기반으로 동적으로 생성: 예: Converted_2025-04-25_1423.pdf path = r\"D:\\vFlat\\A\": JPG 이미지 파일이 있는 폴더의 경로를 정의합니다. r 접두사는 raw string을 의미하며, 백슬래시()를 이스케이프 문자로 해석하지 않고 문자 그대로 사용하도록 합니다. ConvertedToPdfPath = r\"D:\\vFlat\\Apdf\": 변환된 파일(TXT 파일)이 저장될 폴더의 경로를 정의합니다. from PIL import Image import os from datetime import datetime from tqdm import tqdm # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\A&quot; # PDF 저장 폴더 ConvertedToPdfPath = r&quot;D:\\vFlat\\Apdf&quot; # PDF 저장 폴더가 없다면 생성 os.makedirs(ConvertedToPdfPath, exist_ok=True) # 파일 목록 불러오기 및 정렬 file_list = sorted(os.listdir(path)) # 이미지 리스트 생성 img_list = [] k = 0 for i in tqdm(file_list): if i.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;)): k += 1 if k % 100 == 0: print(f&quot;Progress : {k}/{len(file_list)}&quot;) img = Image.open(os.path.join(path, i)) img_rgb = img.convert(&#39;RGB&#39;) img_list.append(img_rgb) # PDF 저장 if img_list: # 현재 시각 기반 동적 파일명 folder_name = os.path.basename(path.rstrip(&quot;\\\\/&quot;)) timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H%M&quot;) output_filename = f&quot;{folder_name}_{timestamp}.pdf&quot; output_path = os.path.join(ConvertedToPdfPath, output_filename) first_img = img_list[0] rest_imgs = img_list[1:] first_img.save(output_path, save_all=True, append_images=rest_imgs) print(f&quot;PDF Saved: {output_path}&quot;) else: print(&quot;No Image File&quot;) 2.4 Batch Script 코드 설명 run_convert.bat 파일을 더블 클릭하면 Python 가상환경의 convert_to_pdf.py가 실행되어 자동으로 PDF 변환을 수행합니다. 완료 후 콘솔창이 멈춰 있어 결과 메시지를 확인할 수 있습니다. D:\\ ├─vFlat\\ │ ├─A\\ &lt;- 이미지 폴더 │ ├─A_pdf\\ &lt;- PDF 저장 폴더 │ ├─convert_to_pdf.py │ └─run_convert.bat &lt;- 더블 클릭해서 실행 set PYTHON_PATH=\"C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe\": Python 실행 파일의 경로를 정의합니다. 이 경로는 Miniconda 환경을 사용하는 경우에 유용하며, 해당 환경에서 코드를 실행하도록 지정합니다. set SCRIPT_PATH=\"C:\\gppj\\auto_ver06\\jpg_convert_pdf.py\": 실행할 Python 스크립트의 경로를 정의합니다. 여기서는 jpg_convert_pdf.py라는 파일이 스크립트가 위치한 디렉토리로 지정됩니다. echo Start. : 콘솔에 “Start.” 메시지를 출력하여 스크립트 실행 시작을 알립니다. %PYTHON_PATH% %SCRIPT_PATH%: 지정된 Python 실행 파일과 스크립트 경로를 사용하여 Python 인터프리터를 호출하고, 해당 스크립트를 실행합니다. 이 부분은 외부 스크립트를 실행하는 역할을 합니다. echo.: 콘솔에 빈 줄을 출력하여 가독성을 높입니다. echo Done.: 콘솔에 “Done.” 메시지를 출력하여 스크립트 완료를 알립니다. pause: 콘솔 창이 자동으로 닫히지 않고 사용자가 아무 키나 누를 때까지 기다립니다. @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\jpg_convert_pdf.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 2.5 결어 이 Python 코드는 JPG 이미지 파일을 TXT 파일로 변환하는 기본적인 기능을 제공합니다. PIL 라이브러리를 사용하여 이미지 파일을 읽고, os 모듈을 사용하여 파일 시스템 작업을 수행하며, tqdm 라이브러리를 사용하여 작업 진행 상황을 시각적으로 표시합니다. 환경 설정을 통해 Python 실행 경로와 스크립트 위치를 명확하게 지정할 수 있습니다. 이 코드는 이미지 처리 파이프라인에서 이미지 파일 정보를 관리하거나 다른 프로그램과 연동하는 데 유용하게 사용될 수 있습니다. "],["Sub00_2025-05-28-15-56.html", "Chapter 3 JPG 이미지를 각각 하나의 TXT 파일로 저장하기 3.1 들어가며 3.2 필요 라이브러리 설치 3.3 python 코딩 설명 3.4 Batch Script 코드 설명 3.5 결어", " Chapter 3 JPG 이미지를 각각 하나의 TXT 파일로 저장하기 3.1 들어가며 이 코드는 디렉토리 내의 모든 JPG 이미지 파일을 읽어와서 각 이미지 파일 이름과 동일한 이름으로 .txt 확장자를 가진 텍스트 파일로 저장하는 Python 스크립트입니다. 주어진 이미지를 텍스트 파일로 변환하는 데 주로 OCR (Optical Character Recognition) 기술이 사용합니다. 이 코드 조각은 pytesseract 라이브러리를 사용하여 이미지에서 텍스트를 추출하고, 결과를 지정된 파일에 저장하도록 설계되었습니다. 또한, 진행 상황을 100개마다 출력하여 사용자에게 작업 진행 상태를 알려줍니다. 3.2 필요 라이브러리 설치 PIL (Pillow): 이미지 파일을 읽고 처리하는 데 사용됩니다. pip install Pillow 명령어를 사용하여 설치할 수 있습니다. pytesseract: 이미지에서 텍스트를 추출하는 OCR 엔진을 제공합니다. Tesseract OCR 엔진이 시스템에 설치되어 있어야 합니다. pip install pytesseract 명령어를 사용하여 설치할 수 있습니다. os: 파일 시스템과 상호 작용하기 위한 기능을 제공합니다. Python에 기본적으로 포함되어 있으므로 별도로 설치할 필요가 없습니다. pip install pillow pytesseract tqdm OCR 프로그램 설치 pc에 이미지 인식을 위한 OCR 프로그램을 설치해야 함. 사이트 https://github.com/UB-Mannheim/tesseract/wiki에서 다운로드 받음 프로그램 인스톨시 Additional language data (download)를 반드시 클릭하여야 한국어 인식이 가능함 pip install pillow 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install pillow 실행 %PYTHON_PATH% -m pip install pillow pause 3.3 python 코딩 설명 lang=’eng+kor’은 영어 + 한글 인식을 위해 설정한 것입니다. → tesseract에 kor 언어 데이터가 설치되어 있어야 작동합니다. 이미지 이름이 test001.jpg면 → test001.txt로 저장됩니다. 100개마다 진행 상황을 출력합니다. 폴더 안의 모든 JPG 이미지를 각각 하나의 TXT 파일로 저장하는 파이썬 코드의 완성본입니다. from PIL import Image import pytesseract import os from tqdm import tqdm # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\man_A02&quot; # TXT 저장 폴더 ConvertedToTxtPath01 = r&quot;D:\\vFlat\\Atxt02&quot; # TXT 저장 폴더가 없다면 생성 os.makedirs(ConvertedToTxtPath01, exist_ok=True) # 파일 목록 불러오기 및 정렬 file_list = sorted(os.listdir(path)) # 처리 시작 for idx, filename in tqdm(enumerate(file_list, start=1)): if filename.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;)): if idx % 100 == 0: print(f&quot;Progress: {idx}/{len(file_list)}&quot;) img_path = os.path.join(path, filename) img = Image.open(img_path) img_rgb = img.convert(&#39;RGB&#39;) # OCR 수행 pytesseract.pytesseract.tesseract_cmd = r&quot;C:\\Program Files\\Tesseract-OCR\\tesseract.exe&quot; text = pytesseract.image_to_string(img_rgb, lang=&#39;eng+kor&#39;) # 결과 저장할 TXT 파일 경로 설정 txt_filename = os.path.splitext(filename)[0] + &quot;.txt&quot; txt_path = os.path.join(ConvertedToTxtPath01, txt_filename) # 텍스트 파일로 저장 with open(txt_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f: f.write(text) print(&quot;모든 이미지가 텍스트 파일로 저장되었습니다.&quot;) text = pytesseract.image_to_string(img_rgb, lang='eng+kor'): pytesseract.image_to_string() 함수는 이미지를 입력받아 텍스트를 추출합니다. 이 함수는 이미지의 RGB 색상 공간 표현(img_rgb)을 인수로 받습니다. lang='eng+kor' 인수는 OCR 엔진에게 영어와 한국어 텍스트를 인식하도록 지시합니다. 이는 이미지에 영어와 한국어가 모두 포함되어 있을 때 유용합니다. 추출된 텍스트는 text 변수에 저장됩니다. txt_filename = os.path.splitext(filename)[0] + \".txt\": os.path.splitext() 함수는 파일 이름을 확장자별로 분리합니다. 예를 들어, filename이 test001.jpg이면 os.path.splitext(filename)은 ('test001', '.jpg')를 반환합니다. [0] 인덱싱은 파일 이름 부분(test001)을 가져옵니다. .txt 확장자를 추가하여 텍스트 파일 이름을 생성합니다. 따라서 filename이 test001.jpg이면 txt_filename은 test001.txt가 됩니다. “100개마다 진행 상황을 출력합니다.”는 코드에 직접적으로 나타나지는 않았지만, 전체 스크립트 내에 루프를 사용하여 파일들을 처리하고, 특정 간격으로 현재 처리된 파일 수를 출력하는 부분이 있을 것으로 예상됩니다. 이러한 진행 상황 표시는 사용자 경험을 향상시키는 데 중요합니다. “폴더 안의 모든 JPG 이미지를 각각 하나의 TXT 파일로 저장하는 파이썬 코드의 완성본입니다.”는 이 코드가 이미지 폴더 내의 모든 JPG 파일을 처리하고, 각 파일을 개별적인 텍스트 파일로 저장하는 전체 스크립트의 일부임을 나타냅니다. 3.4 Batch Script 코드 설명 D:_Atxt02 폴더 안의 모든 *.txt 파일을 하나로 합치는 batch 스크립트 파일명 순서대로 (오름차순) 정확하게 합치고 싶다면, copy *.txt는 안 되고, for문을 써야 해요. (echo?) off : 명령어 실행 내용을 화면에 표시하지 않음 (깔끔하게) cd /d D:_Atxt02 : 해당 폴더로 이동 (/d는 드라이브까지 이동할 때 필요) copy /b *.txt All.txt : 모든 .txt 파일을 이진 모드(binary mode)로 All.txt 파일로 합칩니다. (/b 옵션을 넣으면 깨짐을 방지할 수 있어요.) dir /b /on *.txt : 파일 이름 기준 오름차순 정렬 목록을 가져옴 for /f : 정렬된 파일 목록을 하나씩 순서대로 처리 type “파일명” &gt;&gt; “All.txt” : 하나씩 내용을 이어붙임 (append) pause : 명령어 실행 후 결과를 볼 수 있도록 멈춤 @echo off cd /d D:\\vFlat\\Atxt02 :: 폴더가 없다면 먼저 생성 if not exist &quot;D:\\vFlat\\Atxt03&quot; ( mkdir &quot;D:\\vFlat\\Atxt03&quot; ) :: All.txt 초기화 (기존 파일 있으면 삭제) if exist &quot;D:\\vFlat\\Atxt03\\All.txt&quot; del &quot;D:\\vFlat\\Atxt03\\All.txt&quot; :: 파일명을 오름차순으로 하나씩 읽어서 All.txt에 추가 for /f &quot;delims=&quot; %%i in (&#39;dir /b /on *.txt&#39;) do ( type &quot;%%i&quot; &gt;&gt; &quot;D:\\vFlat\\Atxt03\\All.txt&quot; ) pause 3.5 결어 제공된 코드는 이미지에서 텍스트를 추출하여 개별 .txt 파일로 저장하는 기본적인 기능을 수행합니다. OCR 엔진의 정확도, 이미지 품질 및 언어 설정에 따라 결과의 품질이 달라질 수 있습니다. 또한, 실제 환경에서는 오류 처리, 로깅 및 사용자 인터페이스와 같은 추가적인 기능들을 고려해야 합니다. pytesseract는 강력한 OCR 라이브러리이지만, 완벽하지 않으므로 필요에 따라 후처리 과정을 거쳐야 할 수도 있습니다. "],["Sub00_2025-05-28-21-48.html", "Chapter 4 유튜브 다운로더 만들기 4.1 들어가며 4.2 필요 라이브러리 설치 4.3 python 코딩 설명 4.4 결어", " Chapter 4 유튜브 다운로더 만들기 4.1 들어가며 이 Python 코드는 유튜브 비디오를 다운로드하는 기능을 제공하는 스크립트입니다. 사용자 oem은 myfirstenv라는 특정 Python 환경을 사용하여 이 스크립트를 실행하도록 설정했습니다. 이는 시스템에 여러 버전의 Python이 설치되어 있을 때, 원하는 특정 환경에서 코드를 실행하기 위한 일반적인 방법입니다. 다운로드 기능은 유튜브 비디오를 오프라인으로 시청하거나 다른 용도로 활용할 수 있게 해줍니다. 4.2 필요 라이브러리 설치 pip install pytubefix tqdm 4.3 python 코딩 설명 YouTube 객체 생성 시 URL을 넣음. 가장 높은 화질(get_highest_resolution()) 스트림을 선택. 파일 크기를 가져와서 tqdm에 총량으로 설정. on_progress_callback에 직접 등록해서 chunk 단위로 pbar.update() 호출. 다운로드 완료 후 파일 경로 출력. 예외 발생 시 에러 메시지 출력. 오디오 스트림만 다운로드. from pytubefix import YouTube import os from tqdm import tqdm # 다운로드 된 파일을 저장할 폴더 output_path = r&quot;D:\\movie&quot; # 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # 다운로드 실행 함수 def download_youtube(): url = input(&quot;다운로드할 유튜브 영상 URL을 입력하세요: &quot;) try: yt = YouTube(url) stream = yt.streams.get_highest_resolution() file_size = stream.filesize print(f&quot;&#39;{yt.title}&#39; 다운로드 시작... (파일 크기: {round(file_size / (1024 * 1024), 2)} MB)&quot;) # 다운로드 진행을 tqdm으로 시각화 with tqdm(total=file_size, unit=&#39;B&#39;, unit_scale=True, desc=yt.title) as pbar: def progress_stream(chunk, file_handle, bytes_remaining): pbar.update(len(chunk)) yt.register_on_progress_callback(progress_stream) stream.download(output_path=output_path) print(f&quot;다운로드 완료: {os.path.join(output_path, stream.default_filename)}&quot;) except Exception as e: print(f&quot;다운로드 중 오류가 발생했습니다: {e}&quot;) # 함수 호출 if __name__ == &quot;__main__&quot;: download_youtube() 4.4 결어 "],["Sub00_2025-05-28-21-59.html", "Chapter 5 전체 재생목록(Playlist)에 있는 동영상들을 자동으로 순서대로 다운로드 5.1 들어가며 5.2 필요 라이브러리 설치 5.3 python 코딩 설명 5.4 결어", " Chapter 5 전체 재생목록(Playlist)에 있는 동영상들을 자동으로 순서대로 다운로드 5.1 들어가며 이 Python 코드는 유튜브 재생목록의 모든 영상 URL을 자동으로 가져와, 해당 순서대로 다운로드하는 스크립트입니다. YouTube 재생목록의 주소를 입력하여 영상 목록을 가져오고, 각 영상에 대해 가장 높은 해상도의 스트림을 선택하여 다운로드합니다. 코드는 사용자가 입력한 유튜브 재생목록 URL을 기반으로 작동하며, 지정된 출력 경로에 다운로드된 파일을 저장합니다. 이 스크립트는 특히 여러 개의 동영상으로 구성된 강의나 튜토리얼과 같은 콘텐츠를 쉽게 다운로드하는 데 유용합니다. 5.2 필요 라이브러리 설치 pip install pytubefix tqdm 5.3 python 코딩 설명  브라우저에서 URL 복사하는 법 원하는 웹페이지 열기 (유튜브 링크가 있는 페이지) 주소창 클릭 → 전체 선택 → Ctrl+C 또는 마우스 오른쪽 → 복사 코드의 page_url = “…” 부분에 붙여넣기  주요 포인트 Playlist: 재생목록의 모든 영상 URL을 자동으로 가져옴 progressive=True : 영상+오디오가 함께 있는 스트림 선택 order_by(‘resolution’).desc(): 가장 고해상도 영상 우선 다운로드 tqdm: 진행률 표시줄로 다운로드 상황 시각화 from pytubefix import Playlist, YouTube import os from tqdm import tqdm # 유튜브 재생목록 URL playlist_url = input(&quot;다운로드할 유튜브 재생목록 URL을 입력하세요: &quot;) # 다운로드 경로 output_path = r&quot;D:\\movie\\Miarti_Sewing Tips\\Tricks And Tips Jeans&quot; os.makedirs(output_path, exist_ok=True) # 재생목록 불러오기 playlist = Playlist(playlist_url) print(f&quot; 재생목록 제목: {playlist.title}&quot;) print(f&quot; 총 {len(playlist.video_urls)}개의 영상이 감지되었습니다.\\n&quot;) # 동영상 하나씩 다운로드 for url in tqdm(playlist.video_urls, desc=&quot;다운로드 중&quot;): try: yt = YouTube(url) stream = yt.streams.filter(progressive=True, file_extension=&#39;mp4&#39;)\\ .order_by(&#39;resolution&#39;).desc().first() if stream: print(f&quot; {yt.title} 다운로드 중...&quot;) stream.download(output_path) else: print(f&quot;❌ 스트림 없음: {url}&quot;) except Exception as e: print(f&quot;⚠️ 오류 발생: {url} - {e}&quot;) print(&quot;✅ 재생목록 전체 다운로드 완료!&quot;) 5.4 결어 이 Python 코드는 유튜브 재생목록의 영상을 자동으로 다운로드하는 강력한 도구입니다. pytubefix 라이브러리의 기능을 활용하여 다양한 옵션을 설정하고, 사용자에게 편리한 방식으로 다운로드 작업을 수행할 수 있습니다. 특히 강의나 튜토리얼 등 여러 개의 영상으로 구성된 콘텐츠를 효율적으로 관리하고 다운로드하는 데 유용합니다. "],["Sub00_2025-05-30-06-05.html", "Chapter 6 ISBN을 한 번에 입력받아 도서 정보를 조회해 APA 스타일로 bib파일 출력하기_국제 출판 데이터에 특화 6.1 들어가며 6.2 필요 라이브러리 설치 6.3 python 코딩 설명 6.4 결어", " Chapter 6 ISBN을 한 번에 입력받아 도서 정보를 조회해 APA 스타일로 bib파일 출력하기_국제 출판 데이터에 특화 6.1 들어가며 이 Python 프로그램은 ISBN(International Standard Book Number)을 입력받아 온라인에서 해당 도서의 정보를 조회하고, APA(American Psychological Association) 스타일로 포맷된 참고문헌 리스트(bibliography)를 생성하여 지정된 폴더에 저장하는 역할을 수행합니다. 특히, Open Library API를 사용하여 책 정보를 검색하며, 이 API는 주로 북미 및 국제 출판 데이터에 특화되어 있어 국내 서적 정보의 정확도가 낮을 수 있다는 점을 고려해야 합니다. 이 프로그램은 여러 ISBN을 한 번에 입력받아 처리할 수 있도록 설계되어 효율적인 작업 처리가 가능합니다. 6.2 필요 라이브러리 설치 pip install requests tqdm 6.3 python 코딩 설명 아래는 ISBN을 입력하면 온라인에서 도서 정보를 조회한 후, APA 스타일의 참고문헌(bibliography)을 생성해주는 Python 프로그램입니다. 아래는 여러 개의 ISBN을 한 번에 입력받아 각각에 대해 도서 정보를 조회하고, APA 스타일로 포맷된 참고문헌 리스트를 D:폴더에 텍스트 파일로 저장하는 파이썬 코드입니다. 이 프로그램은 Open Library API를 사용하여 ISBN으로 책 정보를 검색합니다. 9791187444886처럼 국내 ISBN(979-로 시작)은 Open Library API에서 종종 정보를 제공하지 않아 “도서 정보를 찾을 수 없습니다” 메시지가 뜹니다. 이 API는 주로 북미/국제 출판 데이터에 특화되어 있기 때문에 국내 서적 데이터는 빈약합니다. import requests import os from datetime import datetime from tqdm import tqdm import re # BibTeX 파일 저장 경로 output_dir = r&quot;D:\\APA&quot; os.makedirs(output_dir, exist_ok=True) bibtex_file = os.path.join(output_dir, &quot;book.bib&quot;) # BibTeX key 정리용 def sanitize_bibtex_key(text): return re.sub(r&#39;\\W+&#39;, &#39;&#39;, text).lower() # Open Library API에서 책 정보 조회 def get_book_info_openlibrary(isbn): url = f&quot;https://openlibrary.org/api/books?bibkeys=ISBN:{isbn}&amp;format=json&amp;jscmd=data&quot; response = requests.get(url) if response.status_code != 200: return None data = response.json() book_data = data.get(f&quot;ISBN:{isbn}&quot;) if not book_data: return None title = book_data.get(&quot;title&quot;, &quot;Unknown Title&quot;) authors = [author[&quot;name&quot;] for author in book_data.get(&quot;authors&quot;, [])] author = &quot; and &quot;.join(authors) if authors else &quot;Unknown Author&quot; publishers = [pub[&quot;name&quot;] for pub in book_data.get(&quot;publishers&quot;, [])] publisher = publishers[0] if publishers else &quot;Unknown Publisher&quot; year = book_data.get(&quot;publish_date&quot;, &quot;n.d.&quot;) year = re.findall(r&#39;\\d{4}&#39;, year) year = year[0] if year else &quot;n.d.&quot; return { &quot;title&quot;: title, &quot;author&quot;: author, &quot;publisher&quot;: publisher, &quot;year&quot;: year, &quot;isbn&quot;: isbn, &quot;address&quot;: &quot;unknown&quot; } # BibTeX 항목 만들기 def make_bibtex_entry(book): first_author_lastname = book[&quot;author&quot;].split()[0].lower() key = sanitize_bibtex_key(first_author_lastname + book[&quot;year&quot;]) return f&quot;&quot;&quot;@Book{{{key}, title = {{{book[&#39;title&#39;]}}}, author = {{{book[&#39;author&#39;]}}}, publisher = {{{book[&#39;publisher&#39;]}}}, address = {{{book[&#39;address&#39;]}}}, year = {{{book[&#39;year&#39;]}}}, note = {{ISBN {book[&#39;isbn&#39;]}}} }}&quot;&quot;&quot; # 메인 실행 def main(): print(&quot; ISBN을 쉼표(,) 또는 줄바꿈으로 입력하세요:&quot;) raw_input = input(&quot;ISBN 목록 입력: &quot;) isbn_list = [isbn.strip().replace(&quot;-&quot;, &quot;&quot;) for isbn in raw_input.replace(&quot;\\n&quot;, &quot;,&quot;).split(&quot;,&quot;) if isbn.strip()] bib_entries = [] print(&quot;\\n 도서 정보 조회 중...&quot;) for isbn in tqdm(isbn_list, desc=&quot;진행 상황&quot;, unit=&quot;권&quot;): try: book = get_book_info_openlibrary(isbn) if book: bib = make_bibtex_entry(book) bib_entries.append(bib) else: print(f&quot;{isbn}: ❌ 도서 정보를 찾을 수 없습니다.&quot;) except Exception as e: print(f&quot;{isbn}: ⚠️ 오류 발생 - {e}&quot;) if bib_entries: with open(bibtex_file, &quot;a&quot;, encoding=&quot;utf-8&quot;) as f: f.write(&quot;\\n\\n&quot; + &quot;\\n\\n&quot;.join(bib_entries)) print(f&quot;\\n✅ BibTeX 항목이 누적 저장되었습니다:\\n{bibtex_file}&quot;) else: print(&quot;❌ 저장할 항목이 없습니다.&quot;) if __name__ == &quot;__main__&quot;: main() Open Library API가 조회 가능한 경우 전 세계 주요 출판사 및 출판된 책은 대부분 등록되어 있음 ISBN으로 직접 조회하는 경우, 등록된 경우라면 언어와 상관없이 검색 가능 예시 (한국어 도서 포함): 6.4 결어 이 Python 프로그램은 ISBN을 입력받아 온라인에서 도서 정보를 조회하고, APA 스타일로 포맷된 참고문헌 목록을 생성하는 유용한 도구입니다. Open Library API를 활용하여 다양한 도서 정보를 쉽게 얻을 수 있으며, APA 스타일 규칙에 맞춰 정확하고 일관성 있는 참고문헌 리스트를 만들 수 있습니다. 국내 서적 데이터의 부족이라는 한계가 있지만, 북미 및 국제 출판 데이터에는 효과적으로 활용될 수 있습니다. API 오류 처리 및 예외 처리를 통해 프로그램의 안정성을 높일 수 있습니다. "],["Sub00_2025-07-21-17-36.html", "Chapter 7 Pdf를 Txt 파일로 전환 7.1 들어가며 7.2 필요 라이브러리 설치 7.3 python 코딩 설명 7.4 결어", " Chapter 7 Pdf를 Txt 파일로 전환 7.1 들어가며 이 코드는 분할된 PDF 파일들을 읽어 내용을 추출하고, 각 페이지의 텍스트를 별도의 .txt 파일로 저장하는 파이썬 스크립트입니다. PDF (Portable Document Format)는 문서 내용을 보존하기 위한 일반적인 파일 형식이지만, 텍스트를 직접적으로 복사하기 어려울 때가 있습니다. 따라서 PDF에서 텍스트 추출 작업을 수행하여 원하는 정보를 쉽게 활용할 수 있도록 합니다. 이 코드는 특히 분할된 PDF 파일을 처리하도록 설계되었으며, 작업 진행 상황을 시각적으로 보여주는 tqdm 라이브러리를 사용하여 사용자 경험을 향상시킵니다. 이러한 텍스트 추출은 정보 아키텍처, 문서 관리 시스템 구축, 데이터 분석 등 다양한 분야에서 활용됩니다. 7.2 필요 라이브러리 설치 이 코드를 실행하기 전에 몇 가지 파이썬 라이브러리를 설치해야 합니다. 터미널 또는 명령 프롬프트에서 다음 명령을 사용하여 설치할 수 있습니다. PyMuPDF (fitz): PDF 파일을 읽고 페이지별로 텍스트를 추출하는 데 사용됩니다. PyPDF2: PDF 파일을 읽고 쓰기 위한 라이브러리입니다. (현재 코드에서는 주로 파일 목록을 얻는데 사용) tqdm: 루프의 진행 상황을 시각적으로 표시하여 사용자에게 정보를 제공합니다. pip install PyPDF2 PyMuPDF tqdm 7.3 python 코딩 설명 지정된 폴더 내 PDF 파일들을 읽음 각 PDF를 1페이지씩 분할하여 저장 분할된 각 페이지 PDF에서 텍스트 추출 추출된 텍스트를 .txt 파일로 저장 tqdm으로 진행률 표시 import os import fitz # PyMuPDF from PyPDF2 import PdfReader, PdfWriter from tqdm import tqdm # 원본 PDF가 있는 폴더 input_folder = r&quot;C:\\gppj\\gppj05\\x\\pdf_files&quot; # 1페이지씩 분할된 PDF 저장 폴더 split_pdf_folder = os.path.join(input_folder, &quot;split_pages&quot;) os.makedirs(split_pdf_folder, exist_ok=True) # 텍스트 파일 저장 폴더 txt_folder = os.path.join(input_folder, &quot;txt_pages&quot;) os.makedirs(txt_folder, exist_ok=True) # PDF 파일 목록 pdf_files = sorted([f for f in os.listdir(input_folder) if f.lower().endswith(&#39;.pdf&#39;)]) print(&quot; PDF 분할 및 텍스트 추출 시작...&quot;) for pdf_file in tqdm(pdf_files, desc=&quot;총 PDF 처리 중&quot;): pdf_path = os.path.join(input_folder, pdf_file) pdf_name = os.path.splitext(pdf_file)[0] # PDF 열기 reader = PdfReader(pdf_path) total_pages = len(reader.pages) for i in range(total_pages): # PDF 페이지 분할 저장 writer = PdfWriter() writer.add_page(reader.pages[i]) split_filename = f&quot;{pdf_name}_page_{i+1}.pdf&quot; split_path = os.path.join(split_pdf_folder, split_filename) with open(split_path, &quot;wb&quot;) as f: writer.write(f) # 텍스트 추출 doc = fitz.open(split_path) text = doc[0].get_text() doc.close() # 텍스트 파일 저장 txt_filename = f&quot;{pdf_name}_page_{i+1}.txt&quot; txt_path = os.path.join(txt_folder, txt_filename) with open(txt_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(text) print(&quot;\\n✅ 모든 PDF → 텍스트 추출 완료!&quot;) print(f&quot; 분할된 PDF 저장 폴더: {split_pdf_folder}&quot;) print(f&quot; 텍스트 파일 저장 폴더: {txt_folder}&quot;) C: ├── pdf_files │ ├── myfile1.pdf │ ├── myfile2.pdf ├── split_pages │ ├── myfile1_page_1.pdf │ ├── myfile1_page_2.pdf ├── txt_pages │ ├── myfile1_page_1.txt │ ├── myfile1_page_2.txt 7.4 결어 이 파이썬 코드는 PDF 파일을 텍스트 파일로 변환하는 데 유용한 도구입니다. PyMuPDF 라이브러리를 사용하여 PDF 내용을 효율적으로 추출하고, tqdm 라이브러리를 통해 작업 진행 상황을 사용자에게 제공하여 편의성을 높였습니다. 이 코드는 정보 아키텍처 구축, 문서 데이터 분석 등 다양한 분야에서 활용될 수 있습니다. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
