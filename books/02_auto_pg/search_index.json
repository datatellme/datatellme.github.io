[["index.html", "파이썬 자동화 프로그램 만들기 이 책에게 관하여", " 파이썬 자동화 프로그램 만들기 psnam 2025-05-28 이 책에게 관하여 이 책은 파이썬 자동화 프로그램을 제작하기 위해서 작성했습니다. "],["Sub00_2025-05-26-22-29.html", "Chapter 1 Mp3 파일들을 하나의 파일로 합치기 1.1 들어가며 1.2 업무자동화 설계하기 1.3 코딩하기 1.4 결어", " Chapter 1 Mp3 파일들을 하나의 파일로 합치기 1.1 들어가며 여러개의 Mp3 파일을 하나의 Mp3 파일로 합치는 자동화 프로그램을 만든다. 오디오 CD에서 Mp3 파일로 변환면 트랙별로 만들어진다. 각 트랙의 Mp3 파일을 하나의 Mp3 파일로 합친다. 1.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 예전에 듣던 클래식 오디오 CD가 있는데 CD 플래이어가 없어서 Mp3 파일로 변환해서 듣고자 한다. CD 플에이어가 장착되어 있는 예전 노트북을 찾아 미디어 플래이어로 오디오를 Mp3로 변환 한다. 왜 만드는가? 핸드폰이나 아이패드에 Mp3 파일을 복사하여 클래식 음악을 듣기 위해서 만들게 되었다. 작업 쪼개기 핵심 내용: 1단계: 오디오 CD를 Mp3로 변환하여 A폴더에 준비한다. 2단계: A폴더에 있는 Mp3 파일들을 순서대로 합쳐서 B폴더에 A폴더 이름으로 Mp3파일을 생성한다. 3단계: 배치 파일을 만들어 실행한다. 필요 라이브러리 설치 moviepy: Mp3를 합치는 라이브러리 tqdm: 진행 상황을 나타내는 라이브러리 pip install moviepy tqdm pip install moviepy 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install moviepy 실행 %PYTHON_PATH% -m pip install moviepy pause 1.3 코딩하기 1 단계 작업 sample 2 단계 작업 clips.append(audio): 리스트에 클립을 추가하는 부분 write_audiofile(): 오디오 저장하기 출력 MP3는 moviepy에서 내부적으로 ffmpeg를 사용하므로, 시스템에 ffmpeg가 설치되어 있어야 오류 없이 작동합니다. from moviepy.editor import concatenate_audioclips, AudioFileClip import os from tqdm import tqdm from datetime import datetime # 원본 Mp3 파일이 있는 폴더 path = r&quot;D:\\music\\WRC_003SB\\WRC_003SB_The Destiny&quot; # 합쳐진 Mp3 파일을 저장할 폴더 output_path = r&quot;D:\\music\\WRC_000SB_all_01&quot; # Mp3 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # Mp3 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mp3&#39;)]) # 모든 오디오 클립 읽기 clips = [] print(&quot; Mp3 파일 읽는 중...&quot;) for file_name in tqdm(file_list, desc=&quot;MP3 읽는 중&quot;): mp3_file = os.path.join(path, file_name) try: audio = AudioFileClip(mp3_file) clips.append(audio) except Exception as e: print(f&quot;❌ 오류 발생: {file_name} - {e}&quot;) # 오디오 클립 이어붙이기 if clips: print(&quot;️ 클립 합치는 중...&quot;) final_clip = concatenate_audioclips(clips) # 현재 시각 기반 동적 파일명 생성 folder_name = os.path.basename(path.rstrip(&quot;\\/&quot;)) timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H%M&quot;) output_filename = f&quot;{folder_name}_{timestamp}.mp3&quot; output_file = os.path.join(output_path, output_filename) # 최종 파일 저장 final_clip.write_audiofile(output_file) # 모든 클립 닫기 for clip in clips: clip.close() print(f&quot;✅ 모든 Mp3 파일이 저장되었습니다: {output_file}&quot;) else: print(&quot;❌ 합칠 mp3 파일이 없습니다.&quot;) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mp3_convert_all_01.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 1.4 결어 "],["Sub00_2025-05-28-10-58.html", "Chapter 2 jpg파일들을 전자책(epub)으로 만들기 2.1 들어가며 2.2 업무자동화 설계하기 2.3 코딩하기 2.4 결어", " Chapter 2 jpg파일들을 전자책(epub)으로 만들기 2.1 들어가며 여러개의 jpg 파일들을 하나의 epub 파일로 합치는 자동화 프로그램을 만든다. 손쉽게 전자책을 만들 수 있다. 2.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 여러 개의 .jpg 이미지를 하나의 EPUB 전자책으로 만들기 각 이미지는 한 페이지로 취급 표지, 목차, 타이틀 자동 생성 (기본 설정) 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 pip install ebooklib pillow tqdm pip install ebooklib 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install ebooklib 실행 %PYTHON_PATH% -m pip install ebooklib pause 2.3 코딩하기 1 단계 작업 2 단계 작업 .epub 확장자: 전자책 표준 형식 각 이미지 → HTML 페이지: 책의 각 페이지로 렌더링됨 태그 사용: 이미지가 직접 페이지로 표시됨 이미지 파일을 epub 내부에 추가 (book.add_item) HTML 페이지에서 img src=“images/파일명.jpg”로 참조 img src=“images/xxx.jpg”: base64 대신 외부 파일 참조 방식 book.add_item(image_item): 이미지 파일을 EPUB 패키지에 등록 HTML 페이지를 epub.EpubHtml로 각각 생성: ReadEra 호환 spine 구성 유지 from ebooklib import epub from PIL import Image import os from tqdm import tqdm from datetime import datetime # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\A&quot; ConvertedToEpubPath = r&quot;D:\\vFlat\\A_pub&quot; os.makedirs(ConvertedToEpubPath, exist_ok=True) file_list = sorted(f for f in os.listdir(path) if f.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;))) book = epub.EpubBook() folder_name = os.path.basename(path.rstrip(&quot;\\\\/&quot;)) timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H%M&quot;) title = f&quot;{folder_name}_{timestamp}&quot; book.set_title(title) book.set_language(&#39;ko&#39;) book.add_author(&#39;AutoEPUB Generator&#39;) epub_pages = [] for idx, filename in enumerate(tqdm(file_list, desc=&quot;EPUB 생성 중&quot;)): image_path = os.path.join(path, filename) # 이미지 파일을 책에 추가 image_item = epub.EpubItem( uid=f&quot;img{idx}&quot;, file_name=f&quot;images/{filename}&quot;, media_type=&quot;image/jpeg&quot;, content=open(image_path, &#39;rb&#39;).read() ) book.add_item(image_item) # 각 페이지 HTML 작성 (외부 참조 방식) html = f&#39;&#39;&#39; &lt;html&gt; &lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt; &lt;body style=&quot;text-align:center; margin:0; padding:0; background-color:black;&quot;&gt; &lt;img src=&quot;images/{filename}&quot; style=&quot;width:100%; max-width:100%;&quot;/&gt; &lt;/body&gt; &lt;/html&gt; &#39;&#39;&#39; page = epub.EpubHtml(title=f&#39;Page {idx+1}&#39;, file_name=f&#39;page_{idx+1}.xhtml&#39;, content=html) book.add_item(page) epub_pages.append(page) # Spine 및 TOC book.toc = tuple(epub_pages) book.spine = [&#39;nav&#39;] + epub_pages book.add_item(epub.EpubNcx()) book.add_item(epub.EpubNav()) # 저장 output_filename = f&quot;{title}.epub&quot; output_path = os.path.join(ConvertedToEpubPath, output_filename) epub.write_epub(output_path, book, {}) print(f&quot;✅ ReadEra 호환 EPUB 저장 완료: {output_path}&quot;) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\jpg_convert_epub.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 2.4 결어 "],["Sub00_2025-05-28-12-24.html", "Chapter 3 jpg파일들을 pdf로 만들기 3.1 들어가며 3.2 업무자동화 설계하기 3.3 코딩하기 3.4 결어", " Chapter 3 jpg파일들을 pdf로 만들기 3.1 들어가며 여러개의 jpg 파일들을 하나의 pdf 파일로 합치는 자동화 프로그램을 만든다. 3.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 pip install pillow tqdm pip install tqdm 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install tqdm 실행 %PYTHON_PATH% -m pip install tqdm pause 3.3 코딩하기 1 단계 작업 2 단계 작업 이미지가 들어 있는 폴더 경로: D: PDF가 저장될 폴더: D:_pdf: 폴더가 없다면 자동 생성 PDF 파일 이름: 현재 날짜+시간 기반으로 동적으로 생성: 예: Converted_2025-04-25_1423.pdf from PIL import Image import os from datetime import datetime from tqdm import tqdm # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\A&quot; # PDF 저장 폴더 ConvertedToPdfPath = r&quot;D:\\vFlat\\Apdf&quot; # PDF 저장 폴더가 없다면 생성 os.makedirs(ConvertedToPdfPath, exist_ok=True) # 파일 목록 불러오기 및 정렬 file_list = sorted(os.listdir(path)) # 이미지 리스트 생성 img_list = [] k = 0 for i in tqdm(file_list): if i.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;)): k += 1 if k % 100 == 0: print(f&quot;Progress : {k}/{len(file_list)}&quot;) img = Image.open(os.path.join(path, i)) img_rgb = img.convert(&#39;RGB&#39;) img_list.append(img_rgb) # PDF 저장 if img_list: # 현재 시각 기반 동적 파일명 folder_name = os.path.basename(path.rstrip(&quot;\\\\/&quot;)) timestamp = datetime.now().strftime(&quot;%Y-%m-%d_%H%M&quot;) output_filename = f&quot;{folder_name}_{timestamp}.pdf&quot; output_path = os.path.join(ConvertedToPdfPath, output_filename) first_img = img_list[0] rest_imgs = img_list[1:] first_img.save(output_path, save_all=True, append_images=rest_imgs) print(f&quot;PDF Saved: {output_path}&quot;) else: print(&quot;No Image File&quot;) 3 단계 작업 run_convert.bat 파일을 더블 클릭하면 Python 가상환경의 convert_to_pdf.py가 실행되어 자동으로 PDF 변환을 수행합니다. 완료 후 콘솔창이 멈춰 있어 결과 메시지를 확인할 수 있습니다. D:\\ ├─vFlat\\ │ ├─A\\ &lt;- 이미지 폴더 │ ├─A_pdf\\ &lt;- PDF 저장 폴더 │ ├─convert_to_pdf.py │ └─run_convert.bat &lt;- 더블 클릭해서 실행 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\jpg_convert_pdf.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 3.4 결어 "],["Sub00_2025-05-28-15-56.html", "Chapter 4 JPG 이미지를 각각 하나의 TXT 파일로 저장하기 4.1 들어가며 4.2 업무자동화 설계하기 4.3 코딩하기 4.4 결어", " Chapter 4 JPG 이미지를 각각 하나의 TXT 파일로 저장하기 4.1 들어가며 4.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 pip install pillow pytesseract tqdm pip install pillow 실행 bat 파일 @echo off :: Miniconda 환경의 Python 실행 경로 지정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; :: pip install pillow 실행 %PYTHON_PATH% -m pip install pillow pause 4.3 코딩하기 1 단계 작업 2 단계 작업 lang=’eng+kor’은 영어 + 한글 인식을 위해 설정한 것입니다. → tesseract에 kor 언어 데이터가 설치되어 있어야 작동합니다. 이미지 이름이 test001.jpg면 → test001.txt로 저장됩니다. 100개마다 진행 상황을 출력합니다. 폴더 안의 모든 JPG 이미지를 각각 하나의 TXT 파일로 저장하는 파이썬 코드의 완성본입니다. from PIL import Image import pytesseract import os from tqdm import tqdm # 원본 이미지 폴더 path = r&quot;D:\\vFlat\\man_A02&quot; # TXT 저장 폴더 ConvertedToTxtPath01 = r&quot;D:\\vFlat\\Atxt02&quot; # TXT 저장 폴더가 없다면 생성 os.makedirs(ConvertedToTxtPath01, exist_ok=True) # 파일 목록 불러오기 및 정렬 file_list = sorted(os.listdir(path)) # 처리 시작 for idx, filename in tqdm(enumerate(file_list, start=1)): if filename.lower().endswith((&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;)): if idx % 100 == 0: print(f&quot;Progress: {idx}/{len(file_list)}&quot;) img_path = os.path.join(path, filename) img = Image.open(img_path) img_rgb = img.convert(&#39;RGB&#39;) # OCR 수행 pytesseract.pytesseract.tesseract_cmd = r&quot;C:\\Program Files\\Tesseract-OCR\\tesseract.exe&quot; text = pytesseract.image_to_string(img_rgb, lang=&#39;eng+kor&#39;) # 결과 저장할 TXT 파일 경로 설정 txt_filename = os.path.splitext(filename)[0] + &quot;.txt&quot; txt_path = os.path.join(ConvertedToTxtPath01, txt_filename) # 텍스트 파일로 저장 with open(txt_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f: f.write(text) print(&quot;모든 이미지가 텍스트 파일로 저장되었습니다.&quot;) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\myfirstenv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\jpg_convert_txt.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 4 단계 작업 D:_Atxt02 폴더 안의 모든 *.txt 파일을 하나로 합치는 batch 스크립트 파일명 순서대로 (오름차순) 정확하게 합치고 싶다면, copy *.txt는 안 되고, for문을 써야 해요. (echo?) off : 명령어 실행 내용을 화면에 표시하지 않음 (깔끔하게) cd /d D:_Atxt02 : 해당 폴더로 이동 (/d는 드라이브까지 이동할 때 필요) copy /b *.txt All.txt : 모든 .txt 파일을 이진 모드(binary mode)로 All.txt 파일로 합칩니다. (/b 옵션을 넣으면 깨짐을 방지할 수 있어요.) dir /b /on *.txt : 파일 이름 기준 오름차순 정렬 목록을 가져옴 for /f : 정렬된 파일 목록을 하나씩 순서대로 처리 type “파일명” &gt;&gt; “All.txt” : 하나씩 내용을 이어붙임 (append) pause : 명령어 실행 후 결과를 볼 수 있도록 멈춤 @echo off cd /d D:\\vFlat\\Atxt02 :: 폴더가 없다면 먼저 생성 if not exist &quot;D:\\vFlat\\Atxt03&quot; ( mkdir &quot;D:\\vFlat\\Atxt03&quot; ) :: All.txt 초기화 (기존 파일 있으면 삭제) if exist &quot;D:\\vFlat\\Atxt03\\All.txt&quot; del &quot;D:\\vFlat\\Atxt03\\All.txt&quot; :: 파일명을 오름차순으로 하나씩 읽어서 All.txt에 추가 for /f &quot;delims=&quot; %%i in (&#39;dir /b /on *.txt&#39;) do ( type &quot;%%i&quot; &gt;&gt; &quot;D:\\vFlat\\Atxt03\\All.txt&quot; ) pause 4.4 결어 "],["Sub00_2025-05-28-16-22.html", "Chapter 5 여러 개의 mp4 파일을 읽어서 mp3로 변환하기 5.1 들어가며 5.2 업무자동화 설계하기 5.3 코딩하기 5.4 결어", " Chapter 5 여러 개의 mp4 파일을 읽어서 mp3로 변환하기 5.1 들어가며 5.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 5.3 코딩하기 1 단계 작업 2 단계 작업 여러 개의 mp4 파일을 읽어서 mp3로 변환하고 D:저장하는 파이썬 코드 tqdm 으로 변환 진행 상황을 진행바로 볼 수 있어요. 오디오가 없는 mp4는 건너뛰고 경고를 출력합니다. 저장할 mp3 이름은 원본 mp4 파일 이름을 따릅니다. from moviepy.editor import VideoFileClip import os from tqdm import tqdm # 원본 mp4 파일이 있는 폴더 path = r&quot;C:\\gppj\\data\\worship&quot; # 변환된 mp3 파일을 저장할 폴더 output_path = r&quot;D:\\music&quot; # Mp3 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # mp4 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mp4&#39;)]) # 변환 시작 for file_name in tqdm(file_list, desc=&quot;MP4 to MP3 변환 중&quot;): mp4_file = os.path.join(path, file_name) mp3_file = os.path.join(output_path, os.path.splitext(file_name)[0] + &quot;.mp3&quot;) try: clip = VideoFileClip(mp4_file) if clip.audio is not None: clip.audio.write_audiofile(mp3_file) clip.close() else: print(f&quot;오디오가 없는 파일입니다: {file_name}&quot;) except Exception as e: print(f&quot;오류 발생: {file_name} - {e}&quot;) print(&quot;✅ 모든 MP4 파일이 MP3로 변환되었습니다.&quot;) 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mp4_convert_Mp3.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 5.4 결어 "],["Sub00_2025-05-28-16-33.html", "Chapter 6 폴더 안에 있는 모든 .mp4 파일을 순서대로 하나의 파일로 합치는 것 6.1 들어가며 6.2 업무자동화 설계하기 6.3 코딩하기 6.4 결어", " Chapter 6 폴더 안에 있는 모든 .mp4 파일을 순서대로 하나의 파일로 합치는 것 6.1 들어가며 6.2 업무자동화 설계하기 목표 정하기 무엇을 위해서 만드는가? 왜 만드는가? 작업 쪼개기 핵심 내용: 1단계: 2단계: 3단계: 필요 라이브러리 설치 6.3 코딩하기 1 단계 작업 2 단계 작업 VideoFileClip으로 mp4들을 모두 읽어온 뒤 concatenate_videoclips로 한 번에 이어붙여서 하나의 최종 .mp4 파일로 저장해야 합니다. concatenate_videoclips 사용 여러 개 mp4 파일을 하나로 이어붙임 for 반복하면서 파일마다 저장 ❌ 전부 메모리에 읽은 다음 한번에 합쳐서 저장 method=“compose” 사용 해상도/코덱이 서로 달라도 합칠 수 있게 함 모든 파일 clip.close() 메모리 릴리즈 (안 하면 누수 위험 있음) from moviepy.editor import VideoFileClip, concatenate_videoclips import os from tqdm import tqdm # 원본 Mp4 파일이 있는 폴더 path = r&quot;D:\\data\\moviepy\\20230501&quot; # 합쳐진 Mp4 파일을 저장할 폴더 output_path = r&quot;D:\\data\\moviepy\\20230501_all&quot; # Mp4 저장 폴더가 없다면 생성 os.makedirs(output_path, exist_ok=True) # Mp4 파일 목록 불러오기 및 정렬 file_list = sorted([f for f in os.listdir(path) if f.lower().endswith(&#39;.mp4&#39;)]) # 모든 클립 읽기 clips = [] print(&quot; Mp4 파일 읽는 중...&quot;) for file_name in tqdm(file_list, desc=&quot;MP4 읽는 중&quot;): mp4_file = os.path.join(path, file_name) try: clip = VideoFileClip(mp4_file) clips.append(clip) except Exception as e: print(f&quot;오류 발생: {file_name} - {e}&quot;) # 클립 이어붙이기 if clips: print(&quot;️ 클립 합치는 중...&quot;) final_clip = concatenate_videoclips(clips, method=&quot;compose&quot;) # method=&quot;compose&quot;로 서로 다른 해상도도 가능 # 최종 파일 저장 output_file = os.path.join(output_path, &quot;all.mp4&quot;) final_clip.write_videofile(output_file, codec=&quot;libx264&quot;, audio_codec=&quot;aac&quot;, preset=&quot;ultrafast&quot;) # 모든 클립 닫기 for clip in clips: clip.close() print(&quot;✅ 모든 Mp4 파일이 all.mp4로 합쳐졌습니다.&quot;) else: print(&quot;❌ 합칠 mp4 파일이 없습니다.&quot;) 파일 크기가 커질 수 있어요. (compose 쓸 때) 만약 모든 소스 mp4가 해상도, 코덱이 같으면 method=“chain”으로 더 빠르게 합칠 수 있습니다: final_clip = concatenate_videoclips(clips, method=&quot;chain&quot;) preset=“ultrafast”를 주면 저장 속도가 빨라지지만, 파일 용량은 살짝 늘어납니다. 3 단계 작업 @echo off ::REM 사용자 정의 환경 - 파이썬 실행 경로 및 스크립트 위치 설정 set PYTHON_PATH=&quot;C:\\Users\\oem\\miniconda3\\envs\\mymovienv\\python.exe&quot; set SCRIPT_PATH=&quot;C:\\gppj\\auto_ver06\\Mp4_convert_all.py&quot; echo Start. %PYTHON_PATH% %SCRIPT_PATH% echo. echo Done. pause 6.4 결어 "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
